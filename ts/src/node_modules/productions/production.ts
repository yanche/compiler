
import * as utility from 'utility';

class NodeNumMap {
    private _nodenummap: Map<string, number>;
    private _idGen: utility.IdGen;

    constructor() {
        this._nodenummap = new Map<string, number>();
        this._idGen = new utility.IdGen();
    }
    getOrCreateNum(name: string): number {
        if (this._nodenummap.has(name)) return this._nodenummap.get(name);
        else {
            let id = this._idGen.next();
            this._nodenummap.set(name, id);
            return id;
        }
    }
}

export class Symbol {
    private _terminal: boolean;
    private _name: string;

    constructor(terminal: boolean, name: string) {
        this._terminal = terminal;
        this._name = name;
    }
    isTerminal(): boolean { return this._terminal; }
    getName(): string { return this._name; }
}

export class Production {
    private _lhs: Symbol;
    private _rhs: Array<Symbol>;
    private _id: string;

    constructor(lhs: Symbol, rhs: Array<Symbol>) {
        if (lhs.isTerminal()) throw new Error('left-hand-side of production must be non-terminal');
        this._lhs = lhs;
        this._rhs = rhs || [];
        this._id = this._lhs.getName() + ' -> ' + this._rhs.map(r => r.getName()).join(' ');
    }
    getLHS(): Symbol { return this._lhs; }
    getRHS(): Array<Symbol> { return this._rhs; }
    getId(): string { return this._id; }
    print(): this { console.log(this._id); return this; }
}

export class ProdSet {
    private _startnonterminal: string;
    private _terminals: Set<string>;
    private _nonterminals: Set<string>;
    private _prodidset: Set<string>;
    private _prodmap: Map<string, Array<Array<Symbol>>>;

    constructor(prods: Iterable<Production>) {
        let prodsize = 0, terminals = new Set<string>(), nonterminals = new Set<string>();
        let prodidset = new Set<string>(), nodenummap = new NodeNumMap(), prodmap = new Map<string, Array<Array<Symbol>>>();
        let startnonterminal: string = null, reachedges: Array<utility.Edge> = [];
        for (let prod of prods) {
            let prodid = prod.getId();
            if (prodidset.has(prodid)) throw new Error('duplicate production is not allowed: ' + prodid);
            prodidset.add(prodid);
            let lname = prod.getLHS().getName();
            let lnum = nodenummap.getOrCreateNum(lname);
            if (prodsize === 0) startnonterminal = lname;
            let rhs = prod.getRHS();
            addToMapOfArr(prodmap, lname, rhs);
            nonterminals.add(lname);
            for (let symbol of rhs) {
                let rname = symbol.getName();
                if (symbol.isTerminal()) terminals.add(rname);
                else {
                    nonterminals.add(rname);
                    reachedges.push({ src: lnum, tgt: nodenummap.getOrCreateNum(rname) });
                }
            }
            ++prodsize;
        }
        if (prodmap.size !== nonterminals.size) throw new Error('not all non-terminals appear at LHS');
        if (utility.closure.calcClosureOfOneNode(reachedges, nodenummap.getOrCreateNum(startnonterminal)).size !== nonterminals.size) throw new Error('some non-terminals are unreachable from start symbol');

        this._terminals = terminals;
        this._nonterminals = nonterminals;
        this._startnonterminal = startnonterminal;
        this._prodidset = prodidset;
        this._prodmap = prodmap;
    }
    getNonTerminals(): Set<string> { return this._nonterminals; }
    getTerminals(): Set<string> { return this._terminals; }
    getRHSArr(lhs: string): Array<Array<Symbol>> { return this._prodmap.get(lhs); }
    print(): this { for (let prodid of this._prodidset) console.log(prodid); return this; }
}

function addToMapOfArr(map: Map<any, Array<any>>, key: any, item: any) {
    if (!map.has(key)) map.set(key, [item]);
    else map.get(key).push(item);
}