
import * as p from '../../parser';
import * as fs from 'fs';

let grammar = [
    'PROGRAM -> GLOBAL-STATEMENT-LIST',
    'GLOBAL-STATEMENT-LIST -> GLOBAL-STATEMENT GLOBAL-STATEMENT-LIST ||| GLOBAL-STATEMENT',
    'GLOBAL-STATEMENT -> FUNCTION-DEFINITION ||| CLASS-DEFINITION',
    'FUNCTION-DEFINITION -> void id FUNCTION-DEFINITION-MAIN ||| TYPE-ANNOTATION id FUNCTION-DEFINITION-MAIN',
    'FUNCTION-DEFINITION-MAIN -> ( ARGUMENT-NULLABLE-LIST ) { NULLABLE-STATEMENT-LIST }',
    'NULLABLE-STATEMENT-LIST -> ||| STATEMENT-LIST',
    'TYPE-ANNOTATION -> id ||| [ TYPE-ANNOTATION ]',
    'ARGUMENT-NULLABLE-LIST -> ARGUMENT-LIST ||| ',
    'ARGUMENT-LIST -> VAR-DECLARATION , ARGUMENT-LIST ||| VAR-DECLARATION',
    'VAR-DECLARATION -> TYPE-ANNOTATION id',
    'CLASS-DEFINITION -> class id CLASS-EXTENSION { NULLABLE-CLASS-BODY }',
    'CLASS-EXTENSION -> ||| : id',
    'NULLABLE-CLASS-BODY -> CLASS-BODY ||| ',
    'CLASS-BODY -> CLASS-BODY-ITEM CLASS-BODY ||| CLASS-BODY-ITEM',
    'CLASS-BODY-ITEM -> VAR-DECLARATION ; ||| FUNCTION-DEFINITION ||| constructor FUNCTION-DEFINITION-MAIN',
    'STATEMENT-LIST -> STATEMENT STATEMENT-LIST ||| STATEMENT',
    'STATEMENT -> STATEMENT-ELSE-COMPLETE ||| STATEMENT-ELSE-ABSENT',
    'STATEMENT-ELSE-COMPLETE -> break ; ||| continue ; ||| if ( EXPRESSION ) STATEMENT-ELSE-COMPLETE else STATEMENT-ELSE-COMPLETE ||| ; ||| EXPRESSION ; ||| STATEMENT-BLOCK ||| return ; ||| return EXPRESSION ; ||| do STATEMENT while ( EXPRESSION ) ||| WHILE-FOR-ELSE-COMPLETE ||| TYPE-ANNOTATION id = EXPRESSION ;',
    'STATEMENT-BLOCK -> { NULLABLE-STATEMENT-LIST }',
    'WHILE-FOR-ELSE-COMPLETE -> WHILE-FOR-HEAD STATEMENT-ELSE-COMPLETE',
    'WHILE-FOR-ELSE-ABSENT -> WHILE-FOR-HEAD STATEMENT-ELSE-ABSENT',
    'WHILE-FOR-HEAD -> while ( EXPRESSION ) ||| for ( FOR-LOOP-INIT ; EXPRESSION ; NULLABLE-EXPRESSION )',
    'FOR-LOOP-INIT -> ||| EXPRESSION ||| TYPE-ANNOTATION id = EXPRESSION',
    'NULLABLE-EXPRESSION -> ||| EXPRESSION',
    'STATEMENT-ELSE-ABSENT -> if ( EXPRESSION ) STATEMENT ||| if ( EXPRESSION ) STATEMENT-ELSE-COMPLETE else STATEMENT-ELSE-ABSENT ||| WHILE-FOR-ELSE-ABSENT',
    'EXPRESSION -> LEFT-VAL = EXPRESSION ||| OR-EXPRESSION',
    'OR-EXPRESSION -> OR-EXPRESSION || AND-EXPRESSION ||| AND-EXPRESSION',
    'AND-EXPRESSION -> AND-EXPRESSION && TESTER-EXPRESSION ||| TESTER-EXPRESSION',
    'TESTER-EXPRESSION -> TESTER-EXPRESSION TESTER BOOP-EXPRESSION ||| BOOP-EXPRESSION',
    'TESTER -> != ||| == ||| >= ||| <= ||| > ||| <',
    'BOOP-EXPRESSION -> BOOP-EXPRESSION BOOP SHIFT-EXPRESSION ||| SHIFT-EXPRESSION',
    'BOOP -> & ||| | ||| ^',
    'SHIFT-EXPRESSION -> SHIFT-EXPRESSION SHIFT ADD-EXPRESSION ||| ADD-EXPRESSION',
    'SHIFT -> << ||| >> ||| >>>',
    'ADD-EXPRESSION -> ADD-EXPRESSION ADD MULT-EXPRESSION ||| MULT-EXPRESSION',
    'ADD -> + ||| -',
    'MULT-EXPRESSION -> MULT-EXPRESSION MULT UNARY-EXPRESSION ||| UNARY-EXPRESSION',
    'MULT -> * ||| /',
    'UNARY-EXPRESSION -> UNARY UNARY-EXPRESSION ||| CALL-EXPRESSION',
    'UNARY -> ! ||| ~ ||| -',
    'CALL-EXPRESSION -> FN-NAME ( EXPRESSION-NULLABLE-LIST ) ||| new TYPE-ANNOTATION ( EXPRESSION-NULLABLE-LIST ) ||| DIRECT-VAL ||| LITERAL',
    'FN-NAME -> id ||| super',
    'DIRECT-VAL -> LEFT-VAL ||| ( EXPRESSION ) ||| DIRECT-VAL . id ( EXPRESSION-NULLABLE-LIST )',
    'LEFT-VAL -> id ||| DIRECT-VAL [ EXPRESSION ] ||| DIRECT-VAL . id',
    'LITERAL -> integer ||| boolean ||| null',
    'EXPRESSION-NULLABLE-LIST -> EXPRESSION-LIST ||| ',
    'EXPRESSION-LIST -> EXPRESSION , EXPRESSION-LIST ||| EXPRESSION'
];
// let parser = p.createLR1Parser(grammar, '|||');
// console.log(parser.isValid());
// console.log(parser.stateCount());

let lalrparser = p.createLALR1Parser(grammar, '|||');
// console.log(lalrparser.isValid());
// console.log(lalrparser.stateCount());

// let slrparser = p.createSLR1Parser(grammar, '|||');
// console.log(slrparser.isValid());
// console.log(slrparser.stateCount());

// if (!parser.isValid()) {
//     fs.createWriteStream('./amb_dfa.log').write(parser.stringifyAmbCells(), (err: Error) => {
//         if (err) console.error(err.stack);
//         else console.log('done amb output');
//     });
// }
// parser.prodset.getTerminalsInStr().forEach(x=>console.log(x));
export default lalrparser;
