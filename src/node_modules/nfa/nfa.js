
var utility = require('utility');
var _ = require('lodash');
var State = require('./state.js');

//trans: array of automata.Transition
//starts: start nodes number
//terminals: terminal nodes number
var NFA = function (trans, starts, terminals) {
    if (!Array.isArray(trans) || trans.length === 0) throw new Error('bad input of transition array');
    if (!Array.isArray(starts) || starts.length === 0) throw new Error('invalid input of start nodes');
    if (!Array.isArray(terminals) || terminals.length === 0) throw new Error('invalid input of terminal nodes');
    var statenummap = new Map();
    var statenumset = new Set();
    for (var t = 0; t < trans.length; ++t) {
        var tran = trans[t];
        var state = statenummap.get(tran.srcNode);
        if (state == null) {
            state = new State(tran.srcNode);
            statenummap.set(tran.srcNode, state);
        }
        if (!statenummap.has(tran.tgtNode))
            statenummap.set(tran.tgtNode, new State(tran.tgtNode));
        state.addTransition(tran.symbol, tran.tgtNode);
        statenumset.add(tran.srcNode);
        statenumset.add(tran.tgtNode);
    }

    var epsilontrans = [];
    var statenums = [...statenumset];
    for (var i = 0; i < statenums.length; ++i) {
        var staten = statenums[i];
        var eptranset = statenummap.get(staten).getTransition('');
        if (eptranset == null) epsilontrans.push([staten, staten]); //self loop, just for calculation closure purpose
        else {
            var eptrannodes = [...eptranset];
            for (var q = 0; q < eptrannodes.length; ++q)
                epsilontrans.push([staten, eptrannodes[q]]);
        }
    }

    var startset = new Set();
    for (var i = 0; i < starts.length; ++i) {
        var startnum = starts[i];
        if (!statenummap.has(startnum)) throw new Error('invalid start num: ' + startnum);
        startset.add(startnum);
    }
    var terminalset = new Set();
    for (var i = 0; i < terminals.length; ++i) {
        var terminalnum = terminals[i];
        if (!statenummap.has(terminalnum)) throw new Error('invalid terminal num: ' + terminalnum);
        terminalset.add(terminalnum);
    }

    this._state_num_map = statenummap;
    this._starts = startset; //SET
    this._terminals = terminalset; //SET
    this._epsilon_closure_map = utility.calcClosure(epsilontrans);
    this._starts_closure = this.epsilonClosureOfStates([...startset]);
};
NFA.prototype.epsilonClosureOfStates = function (statenums) {
    return utility.closureOfNodes(statenums, this._epsilon_closure_map);
};
NFA.prototype.accept = function (symbols) {
    if (!utility.isStr(symbols) && (!Array.isArray(symbols) || symbols.some(function (s) { return !utility.isStr(s) || s.length === 0; })))
        throw new Error('bad input of symbols, it could be either string or array of non-empty strings');
    var slen = symbols.length, i = 0;
    var curstatenums = this._starts_closure;
    while (curstatenums.length > 0 && i < slen) {
        var symbol = symbols[i++];
        var movingstatesnums = new Set();
        for (var j = 0; j < curstatenums.length; ++j) {
            var tset = this._state_num_map.get(curstatenums[j]).getTransition(symbol); //transition set
            if (tset == null) continue;
            var mstates = [...tset];
            for (var m = 0; m < mstates.length; ++m)
                movingstatesnums.add(mstates[m]);
        }
        curstatenums = this.epsilonClosureOfStates([...movingstatesnums]);
    }
    var terminals = this._terminals;
    return i === slen && curstatenums.some(function (n) { return terminals.has(n); });
};
NFA.prototype.toDFA = function () {

};

module.exports = NFA;
