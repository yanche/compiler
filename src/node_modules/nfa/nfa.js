
var utility = require('utility');
var _ = require('lodash');
var State = require('./state.js');
var dfa = require('dfa');
var Transition = require('automata').Transition;

//trans: array of automata.Transition
//starts: start nodes number
//terminals: terminal nodes number
var NFA = function (trans, starts, terminals) {
    if (!Array.isArray(trans) || trans.length === 0) throw new Error('bad input of transition array');
    if (!Array.isArray(starts) || starts.length === 0) throw new Error('invalid input of start nodes');
    if (!Array.isArray(terminals) || terminals.length === 0) throw new Error('invalid input of terminal nodes');
    var statenummap = new Map();
    var statenumset = new Set();
    for (var t = 0; t < trans.length; ++t) {
        var tran = trans[t];
        var state = statenummap.get(tran.srcNode);
        if (state == null) {
            state = new State(tran.srcNode);
            statenummap.set(tran.srcNode, state);
        }
        if (!statenummap.has(tran.tgtNode))
            statenummap.set(tran.tgtNode, new State(tran.tgtNode));
        state.addTransition(tran.symbol, tran.tgtNode);
        statenumset.add(tran.srcNode);
        statenumset.add(tran.tgtNode);
    }

    var epsilontrans = [];
    var statenums = [...statenumset];
    for (var i = 0; i < statenums.length; ++i) {
        var staten = statenums[i];
        var eptranset = statenummap.get(staten).getTransition('');
        if (eptranset == null) epsilontrans.push([staten, staten]); //self loop, just for calculation closure purpose
        else {
            var eptrannodes = [...eptranset];
            for (var q = 0; q < eptrannodes.length; ++q)
                epsilontrans.push([staten, eptrannodes[q]]);
        }
    }

    var startset = new Set();
    for (var i = 0; i < starts.length; ++i) {
        var startnum = starts[i];
        if (!statenummap.has(startnum)) throw new Error('invalid start num: ' + startnum);
        startset.add(startnum);
    }
    var terminalset = new Set();
    for (var i = 0; i < terminals.length; ++i) {
        var terminalnum = terminals[i];
        if (!statenummap.has(terminalnum)) throw new Error('invalid terminal num: ' + terminalnum);
        terminalset.add(terminalnum);
    }

    this._state_num_map = statenummap;
    this._starts = startset; //SET
    this._terminals = terminalset; //SET
    this._epsilon_closure_map = utility.calcClosure(epsilontrans);
    this._starts_closure = this.epsilonClosureOfStates([...startset]);
};
NFA.prototype.epsilonClosureOfStates = function (statenums) {
    return utility.closureOfNodes(statenums, this._epsilon_closure_map);
};
NFA.prototype.hasTerminal = function (statenums) {
    var terminals = this._terminals;
    return statenums.some(function (n) { return terminals.has(n); });
};
NFA.prototype.accept = function (symbols) {
    if (!utility.isStr(symbols) && (!Array.isArray(symbols) || symbols.some(function (s) { return !utility.isStr(s) || s.length === 0; })))
        throw new Error('bad input of symbols, it could be either string or array of non-empty strings');
    var slen = symbols.length, i = 0;
    var curstatenums = this._starts_closure;
    while (curstatenums.length > 0 && i < slen) {
        var symbol = symbols[i++];
        var movingstatesnums = new Set();
        for (var j = 0; j < curstatenums.length; ++j) {
            var tset = this._state_num_map.get(curstatenums[j]).getTransition(symbol); //transition set
            if (tset == null) continue;
            var mstates = [...tset];
            for (var m = 0; m < mstates.length; ++m)
                movingstatesnums.add(mstates[m]);
        }
        curstatenums = this.epsilonClosureOfStates([...movingstatesnums]);
    }
    var terminals = this._terminals;
    return i === slen && this.hasTerminal(curstatenums);
};
//return an instance of DFA
NFA.prototype.toDFA = function () {
    var dfaTrans = [];
    var dfaIdGen = new utility.IdGen();
    var dfastatemap = new Map();
    var startid = dfaIdGen.newId(), terminals = [];
    dfastatemap.set(statesId(this._starts_closure), startid);
    if (this.hasTerminal(this._starts_closure)) terminals.push(startid);
    var queue = [this._starts_closure];
    while (queue.length > 0) {
        var curstates = queue.shift();
        var curdfaid = dfastatemap.get(statesId(curstates));
        var tmap = new Map();
        for (var i = 0; i < curstates.length; ++i) {
            var nfastate = this._state_num_map.get(curstates[i]);
            var transymbols = nfastate.getAllTransitionSymbols();
            for (var t = 0; t < transymbols.length; ++t) {
                var symbol = transymbols[t];
                if (symbol === '') continue; //ignore epsilon transition
                var tostates = [...nfastate.getTransition(symbol)]; //array of state id
                var chset = tmap.get(symbol);
                if (chset == null) {
                    chset = new Set();
                    tmap.set(symbol, chset);
                }
                for (var p = 0; p < tostates.length; ++p)
                    chset.add(tostates[p]);
            }
        }
        var tarr = [...tmap];
        for (var i = 0; i < tarr.length; ++i) {
            var tpair = tarr[i];
            var symbol = tpair[0], closurestates = utility.closureOfNodes([...tpair[1]], this._epsilon_closure_map);
            var nfastatesid = statesId(closurestates);
            if (!dfastatemap.has(nfastatesid)) {
                var dfastateid = dfaIdGen.newId();
                dfastatemap.set(nfastatesid, dfastateid);
                if (this.hasTerminal(closurestates)) terminals.push(dfastateid); //set terminal
                queue.push(closurestates);
            }
            else
                var dfastateid = dfastatemap.get(nfastatesid);
            dfaTrans.push(new Transition(curdfaid, dfastateid, symbol)) ;
        }
    }
    return dfa.createDFA(dfaTrans, startid, terminals);
};

var statesId = function (idlist) {
    return idlist.sort(function (v1, v2) { return v1 - v2; }).join(',');
};

module.exports = NFA;
