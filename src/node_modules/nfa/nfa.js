
var utility = require('utility');
var _ = require('lodash');

var epsilonTransitionOfStates = function (states) {
    var retarr = [];
    for (var i = 0; i < states.length; ++i) {
        var state = states[i];
        var eptranset = state.getTransition('');
        var stateid = state.getId();
        if (eptranset == null) retarr.push([stateid, stateid]); //dummy edge to declare the existence of node
        else {
            var eptran = [...eptranset];
            for (var e = 0; e < eptran.length; ++e)
                retarr.push([stateid, eptran[e].getId()]);
        }
    }
    return retarr;
};

var NFA = function (states) {
    if (!Array.isArray(states) || states.length === 0) throw new Error('bad input');
    var statenummap = new Map(), starts = new Set(), terminals = new Set();
    for (var s = 0; s < states.length; ++s) {
        var state = states[s];
        var id = state.getId();
        if (statenummap.has(id)) throw new Error('dup state id: ' + id);
        statenummap.set(id, state);
        if (state.getStart()) starts.add(id);
        if (state.getTerminal()) terminals.add(id);
    }
    if (starts.size === 0) throw new Error('no start state');
    if (terminals.size === 0) throw new Error('no terminal state');

    this._states = states;
    this._state_num_map = statenummap;
    this._starts = starts;
    this._terminals = terminals;
    this._epsilon_closure_map = utility.calcClosure(epsilonTransitionOfStates(states));
    this._starts_closure = this.epsilonClosureOfStates([...starts]);
};
NFA.prototype.epsilonClosureOfStates = function (statenums) {
    return utility.closureOfNodes(statenums, this._epsilon_closure_map);
};
NFA.prototype.accept = function (str) {
    if (!utility.isStr(str)) throw new Error('invalid input, only string is acceptable: ' + str);
    var slen = str.length, i = 0;
    var curstatenums = this._starts_closure;
    while (curstatenums.length > 0 && i < slen) {
        var ch = str[i++];
        var movingstatesnums = new Set();
        for (var j = 0; j < curstatenums.length; ++j) {
            var tset = this._state_num_map.get(curstatenums[j]).getTransition(ch); //transition set
            if (tset == null) continue;
            var mstates = [...tset];
            for (var m = 0; m < mstates.length; ++m)
                movingstatesnums.add(mstates[m].getId());
        }
        curstatenums = this.epsilonClosureOfStates([...movingstatesnums]);
    }
    var terminals = this._terminals;
    return i === slen && curstatenums.some(function (n) { return terminals.has(n); });
};
NFA.prototype.toDFA = function () {

};

module.exports = NFA;
