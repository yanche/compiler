"use strict";
const utility = require('utility');
const DFA_1 = require('DFA');
class State {
    constructor(id) {
        this._id = id;
        this._tranmap = new Map();
    }
    addTransition(str, statenum) {
        if (this._tranmap.has(str))
            this._tranmap.get(str).add(statenum);
        else
            this._tranmap.set(str, new Set().add(statenum));
    }
    getTransition(str) {
        return this._tranmap.get(str);
    }
    getTransitionMap() {
        return this._tranmap;
    }
    getId() {
        return this._id;
    }
}
class NFA {
    constructor(trans, starts, terminals) {
        let statemap = new Map(), stateset = new Set(), statect = 0;
        for (let tran of trans) {
            let state = statemap.get(tran.src);
            if (state == null) {
                state = new State(tran.src);
                statemap.set(tran.src, state);
                ++statect;
            }
            if (!statemap.has(tran.tgt)) {
                statemap.set(tran.tgt, new State(tran.tgt));
                ++statect;
            }
            state.addTransition(tran.str, tran.tgt);
            stateset.add(tran.src);
            stateset.add(tran.tgt);
        }
        if (statect === 0)
            throw new Error('zero state is not good for NFA');
        let epsilontrans = [];
        for (let statenum of stateset) {
            let epset = statemap.get(statenum).getTransition('');
            if (epset == null)
                epsilontrans.push({ src: statenum, tgt: statenum });
            else {
                for (let epstate of epset)
                    epsilontrans.push({ src: statenum, tgt: epstate });
            }
        }
        let startset = new Set(), terminalset = new Set();
        for (let s of starts) {
            if (!statemap.has(s))
                throw new Error('invalid start num: ' + s);
            startset.add(s);
        }
        if (startset.size === 0)
            throw new Error('no start state in NFA');
        for (let t of terminals) {
            if (!statemap.has(t))
                throw new Error('invalid terminal num: ' + t);
            terminalset.add(t);
        }
        if (terminalset.size === 0)
            throw new Error('no terminal state in NFA');
        this._statemap = statemap;
        this._startset = startset;
        this._terminalset = terminalset;
        this._epsilonclosuremap = utility.closure.calcClosure(epsilontrans);
        this._startclosure = this.epsilonClosureOfStates(startset);
    }
    epsilonClosureOfStates(statenums) {
        return utility.closure.closureOfNodes(statenums, this._epsilonclosuremap);
    }
    hasTerminal(statenums) {
        for (let state of statenums) {
            if (this._terminalset.has(state))
                return true;
        }
        return false;
    }
    accept(strarr) {
        let curstatenums = this._startclosure;
        for (let str of strarr) {
            let mstates = new Set();
            for (let state of curstatenums) {
                let tset = this._statemap.get(state).getTransition(str);
                if (tset == null)
                    continue;
                for (let t of tset)
                    mstates.add(t);
            }
            curstatenums = this.epsilonClosureOfStates(mstates);
            if (curstatenums.size === 0)
                return false;
        }
        return this.hasTerminal(curstatenums);
    }
    toDFA() {
        let dfaTrans = [], dfaIdGen = new utility.IdGen();
        let dfastatemap = new Map(), startid = dfaIdGen.next(), terminals = new Set();
        let nfaidofstarts = statesId([...this._startclosure]);
        dfastatemap.set(nfaidofstarts, startid);
        if (this.hasTerminal(this._startclosure))
            terminals.add(startid);
        let queue = [{ set: this._startclosure, id: nfaidofstarts, dfaid: startid }];
        while (queue.length > 0) {
            let cur = queue.shift(), tmp = new Map();
            for (let s of cur.set) {
                let nfastate = this._statemap.get(s);
                for (let tran of nfastate.getTransitionMap()) {
                    let str = tran[0], tgtset = tran[1];
                    if (str.length === 0)
                        continue;
                    let chset = tmp.get(str);
                    if (chset == null) {
                        chset = new Set();
                        tmp.set(str, chset);
                    }
                    for (let t of tgtset)
                        chset.add(t);
                }
            }
            for (let m of tmp) {
                let str = m[0], tset = this.epsilonClosureOfStates(m[1]);
                let nfastatesid = statesId([...tset]), dfaid = null;
                if (!dfastatemap.has(nfastatesid)) {
                    dfaid = dfaIdGen.next();
                    dfastatemap.set(nfastatesid, dfaid);
                    if (this.hasTerminal(tset))
                        terminals.add(dfaid);
                    queue.push({ set: tset, id: nfastatesid, dfaid: dfaid });
                }
                else
                    dfaid = dfastatemap.get(nfastatesid);
                dfaTrans.push(new utility.automata.Transition(cur.dfaid, dfaid, str));
            }
        }
        return DFA_1.createDFA(dfaTrans, startid, terminals);
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = NFA;
function statesId(idlist) {
    return idlist.sort(function (v1, v2) { return v1 - v2; }).join(',');
}
;
//# sourceMappingURL=nfa.js.map