
export class Token {
    rawstr: string;
    symbol: string; //terminal symbol, definitely
}

export abstract class ParseTreeNode {
    protected _symbol: string;
    get symbol(): string { return this._symbol; }
    constructor(sym: string) { this._symbol = sym; }
}

export class ParseTreeMidNode extends ParseTreeNode {
    private _children: Array<ParseTreeNode>;
    get children(): Array<ParseTreeNode> {
        return this._children;
    }
    set children(c: Array<ParseTreeNode>) {
        this._children = c;
    }
}

export class ParseTreeTermNode extends ParseTreeNode {
    private _token: Token;
    get token(): Token {
        return this._token;
    }
    set token(t: Token) {
        if (this._symbol !== t.symbol) throw new Error('symbol does not match: ' + this._symbol + ', ' + t.symbol);
        this._token = t;
    }
}

export class ParseReturn {
    private _accept: boolean;
    private _root: ParseTreeMidNode;
    private _errmsg: string;
    private _errcode: number;

    constructor(accept: boolean, root: ParseTreeMidNode, errmsg?: string, errcode?: number) {
        if (accept) {
            if (root == null) throw new Error('must provide a root node of parse tree if accepted');
            if (errmsg != null || errcode != null) throw new Error('errmsg and errcode must not be specified if accepted');
        }
        else {
            if (root != null) throw new Error('root node must not be specified if not accepted');
            if (errcode == null) throw new Error('must provide an error code if not accepted');
        }
        this._accept = accept;
        this._root = root;
        this._errmsg = errmsg;
        this._errcode = errcode;
    }
    get accept(): boolean { return this._accept; }
    get root(): ParseTreeMidNode { return this._root; }
    get errmsg(): string { return this._errmsg; }
    get errcode(): number { return this._errcode; }
}
