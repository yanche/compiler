
import * as prod from 'productions';

export interface Token {
    rawstr: string;
    symnum: number; //terminal symbol, definitely
}

export abstract class ParseTreeNode {
    protected _symnum: number;
    private _prodset: prod.ProdSet;
    get symnum(): number { return this._symnum; }
    get symstr(): string { return this._prodset.getSymInStr(this._symnum); }
    constructor(sym: number, prodset: prod.ProdSet) {
        this._symnum = sym;
        this._prodset = prodset;
    }
}

export class ParseTreeMidNode extends ParseTreeNode {
    private _children: Array<ParseTreeNode>;
    constructor(sym: number, prodset: prod.ProdSet, children?: Array<ParseTreeNode>) {
        super(sym, prodset);
        this._children = children;
    }
    get children(): Array<ParseTreeNode> {
        return this._children;
    }
    set children(c: Array<ParseTreeNode>) {
        this._children = c;
    }
}

export class ParseTreeTermNode extends ParseTreeNode {
    private _token: Token;
    constructor(sym: number, prodset: prod.ProdSet, token?: Token) {
        super(sym, prodset);
        if (token != null)
            this.token = token;
    }
    get token(): Token {
        return this._token;
    }
    set token(t: Token) {
        if (this._symnum !== t.symnum) throw new Error('symbol does not match: ' + this._symnum + ', ' + t.symnum);
        this._token = t;
    }
}

export class ParseReturn {
    private _accept: boolean;
    private _root: ParseTreeMidNode;
    private _errmsg: string;
    private _errcode: number;

    constructor(accept: boolean, root: ParseTreeMidNode, errmsg?: string, errcode?: number) {
        if (accept) {
            if (root == null) throw new Error('must provide a root node of parse tree if accepted');
            if (errmsg != null || errcode != null) throw new Error('errmsg and errcode must not be specified if accepted');
        }
        else {
            if (root != null) throw new Error('root node must not be specified if not accepted');
            if (errcode == null) throw new Error('must provide an error code if not accepted');
        }
        this._accept = accept;
        this._root = root;
        this._errmsg = errmsg;
        this._errcode = errcode;
    }
    get accept(): boolean { return this._accept; }
    get root(): ParseTreeMidNode { return this._root; }
    get errmsg(): string { return this._errmsg; }
    get errcode(): number { return this._errcode; }
}

export interface IParser {
    parse(tokens: Array<Token>): ParseReturn;
}
