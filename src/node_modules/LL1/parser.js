"use strict";
const p = require('parse');
class LL1ParseTable {
    constructor(prodset) {
        this._table = new Map();
        this._valid = true;
        this._prodset = prodset;
    }
    valid() { return this._valid; }
    add(ntsym, tsym, prodnum) {
        let row = this.getOrCreateParseRow(ntsym);
        let col = row.get(tsym);
        if (col == null) {
            col = new Array();
            row.set(tsym, col);
        }
        else
            this._valid = false;
        col.push(prodnum);
        return this;
    }
    addRange(ntsym, tsyms, prodnum) {
        for (let tsym of tsyms) {
            this.add(ntsym, tsym, prodnum);
        }
        return this;
    }
    getOrCreateParseRow(ntsym) {
        let row = this._table.get(ntsym);
        if (row == null) {
            row = new Map();
            this._table.set(ntsym, row);
        }
        return row;
    }
    getProds(ntsym, tsym) {
        return this._table.get(ntsym).get(tsym) || [];
    }
    getParseRow(ntsym) {
        return this._table.get(ntsym);
    }
    print() {
        if (!this._valid)
            console.log('this is an invalid parse table');
        for (let item of this._table) {
            console.log(this._prodset.getSymInStr(item[0]));
            for (let col of item[1]) {
                console.log('    ' + this._prodset.getSymInStr(col[0]));
                for (let prodid of col[1]) {
                    console.log('        ' + this._prodset.getProdRef(prodid).rnums.map(x => this._prodset.getSymInStr(x)).join(' '));
                }
            }
        }
        return this;
    }
    parse(tokens, startsym) {
        let stack = new Array(), root = new p.ParseTreeMidNode(this._prodset.getSymInStr(startsym)), i = 0;
        stack.push({ node: root, symnum: startsym });
        while (stack.length > 0) {
            let stacktop = stack.pop(), token = ((i === tokens.length) ? { rawstr: '', symbol: '$' } : tokens[i]);
            let node = stacktop.node;
            if (node instanceof p.ParseTreeTermNode) {
                if (node.symbol === token.symbol)
                    node.token = token;
                else
                    return new p.ParseReturn(false, null, 'should not happen, terminal symbol at top of stack does not match with token symbol', 1);
                ++i;
            }
            else if (node instanceof p.ParseTreeMidNode) {
                let prods = this.getProds(stacktop.symnum, this._prodset.getSymNum(token.symbol));
                if (prods.length === 0)
                    return new p.ParseReturn(false, null, 'no production is found for: ' + node.symbol + ', ' + token.symbol, 2);
                if (prods.length > 1)
                    return new p.ParseReturn(false, null, 'more than 1 productions are found for: ' + node.symbol + ', ' + token.symbol, 3);
                let newstackitems = this._prodset.getProdRef(prods[0]).rnums.map(sym => {
                    let symstr = this._prodset.getSymInStr(sym);
                    if (this._prodset.isSymNumTerminal(sym))
                        return { node: new p.ParseTreeTermNode(symstr), symnum: sym };
                    else
                        return { node: new p.ParseTreeMidNode(symstr), symnum: sym };
                });
                node.children = newstackitems.map(n => n.node);
                for (let j = newstackitems.length - 1; j >= 0; --j)
                    stack.push(newstackitems[j]);
            }
        }
        if (i === tokens.length)
            return new p.ParseReturn(true, root);
        else
            return new p.ParseReturn(false, null, 'does not consume all input tokens', 4);
    }
}
class LL1Parser {
    constructor(prodset) {
        let ptable = new LL1ParseTable(prodset);
        let firstsets = prodset.firstSet(), followsets = prodset.followSet(), nullablenonterminals = prodset.nullableNonTerminals();
        for (let nont of prodset.getNonTerminals()) {
            let follow = followsets.get(nont);
            ptable.getOrCreateParseRow(nont);
            for (let prodid of prodset.getProds(nont)) {
                let rsymarr = prodset.getProdRef(prodid).rnums;
                let gonull = true, idx = 0, syms = new Set();
                while (idx < rsymarr.length && gonull) {
                    let rsym = rsymarr[idx];
                    gonull = nullablenonterminals.has(rsym);
                    for (let f of firstsets.get(rsym))
                        syms.add(f);
                    ++idx;
                }
                if (idx === rsymarr.length && gonull) {
                    for (let f of follow)
                        syms.add(f);
                }
                ptable.addRange(nont, syms, prodid);
            }
        }
        this._ptable = ptable;
        this._prodset = prodset;
    }
    valid() { return this._ptable.valid(); }
    parse(tokens) {
        return this._ptable.parse(tokens, this._prodset.getStartNonTerminal());
    }
    getParseRow(nont) {
        return this._ptable.getParseRow(nont);
    }
    getProduction(nont, termi) {
        return this._ptable.getProds(nont, termi);
    }
    print() {
        this._ptable.print();
        return this;
    }
    getSymNum(sym) {
        return this._prodset.getSymNum(sym);
    }
    getProdRef(prodid) {
        return this._prodset.getProdRef(prodid);
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LL1Parser;
//# sourceMappingURL=parser.js.map