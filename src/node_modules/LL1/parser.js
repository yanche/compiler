"use strict";
const p = require('parse');
class LL1ParseTable {
    constructor() {
        this._table = new Map();
        this._valid = true;
    }
    valid() { return this._valid; }
    add(ntsym, tsym, rsymsarr) {
        let row = this._table.get(ntsym);
        if (row == null) {
            row = new Map();
            this._table.set(ntsym, row);
        }
        let col = row.get(tsym);
        if (col == null) {
            col = new Array();
            row.set(tsym, col);
        }
        else
            this._valid = false;
        col.push(rsymsarr);
        return this;
    }
    addRange(ntsym, tsyms, rsymsarr) {
        for (let tsym of tsyms) {
            this.add(ntsym, tsym, rsymsarr);
        }
        return this;
    }
    initRow(nont) {
        this._table.set(nont, new Map());
        return this;
    }
    getProduction(nont, termi) {
        return this._table.get(nont).get(termi) || [];
    }
    getSingleProduction(nont, termi) {
        let prods = this.getProduction(nont, termi);
        if (prods.length === 1)
            return prods[0];
        if (prods.length === 0)
            throw new Error('no production by current non-terminal and terminal symbols: ' + nont + ', ' + termi);
        else
            throw new Error('more than one production exists for given non-terminal and terminal symbols: ' + nont + ', ' + termi);
    }
    getParseRow(nont) {
        return this._table.get(nont);
    }
    print() {
        if (!this._valid)
            console.log('this is an invalid parse table');
        for (let item of this._table) {
            console.log(item[0]);
            for (let col of item[1]) {
                console.log('    ' + col[0]);
                for (let arr of col[1]) {
                    console.log('        ' + arr.map(x => x.getName()).join(' '));
                }
            }
        }
        return this;
    }
    parse(tokens, startsym) {
        let stack = new Array(), root = new p.ParseTreeMidNode(startsym), i = 0;
        stack.push(root);
        while (stack.length > 0) {
            let node = stack.pop(), token = ((i === tokens.length) ? { rawstr: '', symbol: '$' } : tokens[i]);
            if (node instanceof p.ParseTreeTermNode) {
                if (node.symbol === token.symbol)
                    node.token = token;
                else
                    return new p.ParseReturn(false, null, 'should not happen, terminal symbol at top of stack does not match with token symbol', 1);
                ++i;
            }
            else if (node instanceof p.ParseTreeMidNode) {
                let prods = this.getProduction(node.symbol, token.symbol);
                if (prods.length === 0)
                    return new p.ParseReturn(false, null, 'no production is found for: ' + node.symbol + ', ' + token.symbol, 2);
                if (prods.length > 1)
                    return new p.ParseReturn(false, null, 'more than 1 productions are found for: ' + node.symbol + ', ' + token.symbol, 3);
                let nodes = prods[0].map(sym => {
                    if (sym.isTerminal())
                        return new p.ParseTreeTermNode(sym.getName());
                    else
                        return new p.ParseTreeMidNode(sym.getName());
                });
                node.children = nodes;
                for (let j = nodes.length - 1; j >= 0; --j)
                    stack.push(nodes[j]);
            }
        }
        if (i === tokens.length)
            return new p.ParseReturn(true, root);
        else
            return new p.ParseReturn(false, null, 'does not consume all input tokens', 4);
    }
}
class LL1Parser {
    constructor(prodset) {
        let ptable = new LL1ParseTable();
        let firstsets = prodset.firstSet(), followsets = prodset.followSet(), nullablenonterminals = prodset.nullableNonTerminals();
        for (let nont of prodset.getNonTerminals()) {
            let follow = followsets.get(nont);
            ptable.initRow(nont);
            for (let rsymarr of prodset.getRHSArr(nont)) {
                let gonull = true, idx = 0, syms = new Set();
                while (idx < rsymarr.length && gonull) {
                    let rsym = rsymarr[idx];
                    let rname = rsym.getName();
                    gonull = nullablenonterminals.has(rname);
                    for (let f of firstsets.get(rname))
                        syms.add(f);
                    ++idx;
                }
                if (idx === rsymarr.length && gonull) {
                    for (let f of follow)
                        syms.add(f);
                }
                ptable.addRange(nont, syms, rsymarr);
            }
        }
        this._ptable = ptable;
        this._prodset = prodset;
    }
    valid() { return this._ptable.valid(); }
    parse(tokens) {
        return this._ptable.parse(tokens, this._prodset.getStartNonTerminal());
    }
    getParseRow(nont) {
        return this._ptable.getParseRow(nont);
    }
    getProduction(nont, termi) {
        return this._ptable.getProduction(nont, termi);
    }
    getSingleProduction(nont, termi) {
        return this._ptable.getSingleProduction(nont, termi);
    }
    print() {
        this._ptable.print();
        return this;
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LL1Parser;
//# sourceMappingURL=parser.js.map