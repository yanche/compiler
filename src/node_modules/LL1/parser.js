
var utility = require('utility');
var _ = require('lodash');

var LL1Parser = function (prodset) {
    this._originprodset = prodset;
    var lfprodset = prodset.leftFactoredProdSet();
    this._leftfactorprodset = lfprodset;
    var parsetable = new Map();
    this._parsetable = parsetable;
    var firstset = lfprodset.firstSet();
    var followset = lfprodset.followSet();
    this._followset = followset;
    this._firstset = firstset;
    var invalidparsingtable = false;
    lfprodset.getAllNonTerminals().forEach(lstr => {
        var tmap = new Map();
        parsetable.set(lstr, tmap);
        lfprodset.getRHSArr(lstr).forEach(rhs => {
            var idx = 0, goahead = true, fset = new Set();
            while (idx < rhs.length && goahead) {
                var symfset = firstset.get(rhs[idx].getName());
                [...symfset].forEach(str => { if (str.length > 0) fset.add(str); });
                goahead = symfset.has(''); //check next symbol if this one can produce epsilon
                ++idx;
            }
            if (goahead)[...followset.get(lstr)].forEach(str => fset.add(str));
            [...fset].forEach(str => {
                var arr = tmap.get(str);
                if (arr == null) tmap.set(str, [rhs]);
                else {
                    arr.push(rhs);
                    invalidparsingtable = true;
                }
            });
        });
    });
    this._invalidparsingtable = invalidparsingtable;
};
LL1Parser.prototype.parse = function () {

};
LL1Parser.prototype.valid = function () {
    return !this._invalidparsingtable;
};
LL1Parser.prototype.print = function () {
    [...this._parsetable].forEach(pair => {
        var lstr = pair[0], tmap = [...pair[1]];
        tmap.forEach(pair2 => {
            var tsym = pair2[0], rhsarr = pair2[1];
            if (rhsarr.length == 1) console.log([lstr, '->', readableRHS(rhsarr[0]), 'at', tsym].join(' '));
            else {
                console.log([lstr, 'at', tsym, 'has', rhsarr.length, 'choices, not good'].join(' '));
                rhsarr.forEach(rhs => console.log(readableRHS(rhs)));
            }
        });
    });
};

var readableRHS = function (rhs) {
    return rhs.map(r => r.getName()).join(' ');
};

//merge all items in set2 into set1
var mergeSets = function (set1, set2) {
    [...set2].forEach(s => set1.add(s));
};

module.exports = LL1Parser;
