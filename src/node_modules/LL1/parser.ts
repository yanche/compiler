
import * as utility from 'utility';
import * as prod from 'productions';
import * as p from 'parse';

class LL1ParseTable {
    private _table: Map<string, Map<string, Array<Array<prod.Symbol>>>>;
    private _valid: boolean;
    constructor() {
        this._table = new Map<string, Map<string, Array<Array<prod.Symbol>>>>();
        this._valid = true;
    }
    valid(): boolean { return this._valid; }
    add(ntsym: string, tsym: string, rsymsarr: Array<prod.Symbol>): this {
        let row = this._table.get(ntsym);
        if (row == null) {
            row = new Map<string, Array<Array<prod.Symbol>>>();
            this._table.set(ntsym, row);
        }
        let col = row.get(tsym);
        if (col == null) {
            col = new Array<Array<prod.Symbol>>();
            row.set(tsym, col);
        }
        else
            this._valid = false;
        col.push(rsymsarr);
        return this;
    }
    addRange(ntsym: string, tsyms: Iterable<string>, rsymsarr: Array<prod.Symbol>): this {
        for (let tsym of tsyms) {
            this.add(ntsym, tsym, rsymsarr);
        }
        return this;
    }
    initRow(nont: string): this {
        this._table.set(nont, new Map<string, Array<Array<prod.Symbol>>>());
        return this;
    }
    getProduction(nont: string, termi: string): Array<Array<prod.Symbol>> {
        return this._table.get(nont).get(termi) || [];
    }
    getSingleProduction(nont: string, termi: string): Array<prod.Symbol> {
        let prods = this.getProduction(nont, termi);
        if (prods.length === 1) return prods[0];
        if (prods.length === 0) throw new Error('no production by current non-terminal and terminal symbols: ' + nont + ', ' + termi);
        else throw new Error('more than one production exists for given non-terminal and terminal symbols: ' + nont + ', ' + termi);
    }
    getParseRow(nont: string): Map<string, Array<Array<prod.Symbol>>> {
        return this._table.get(nont);
    }
    print(): this {
        if (!this._valid) console.log('this is an invalid parse table');
        for (let item of this._table) {
            console.log(item[0]);
            for (let col of item[1]) {
                console.log('    ' + col[0]);
                for (let arr of col[1]) {
                    console.log('        ' + arr.map(x => x.getName()).join(' '));
                }
            }
        }
        return this;
    }
    parse(tokens: Array<p.Token>, startsym: string): p.ParseReturn {
        let stack = new Array<p.ParseTreeNode>(), root = new p.ParseTreeMidNode(startsym), i = 0;
        stack.push(root);
        while (stack.length > 0) {
            let node = stack.pop(), token: p.Token = ((i === tokens.length) ? { rawstr: '', symbol: '$' } : tokens[i]);
            if (node instanceof p.ParseTreeTermNode) {
                if (node.symbol === token.symbol) node.token = token;
                else return new p.ParseReturn(false, null, 'should not happen, terminal symbol at top of stack does not match with token symbol', 1);
                ++i;
            }
            else if (node instanceof p.ParseTreeMidNode) {
                let prods = this.getProduction(node.symbol, token.symbol);
                if (prods.length === 0) return new p.ParseReturn(false, null, 'no production is found for: ' + node.symbol + ', ' + token.symbol, 2);
                if (prods.length > 1) return new p.ParseReturn(false, null, 'more than 1 productions are found for: ' + node.symbol + ', ' + token.symbol, 3);
                let nodes = prods[0].map(sym => {
                    if (sym.isTerminal()) return new p.ParseTreeTermNode(sym.getName());
                    else return new p.ParseTreeMidNode(sym.getName());
                });
                node.children = nodes;
                for (let j = nodes.length - 1; j >= 0; --j) stack.push(nodes[j]);
            }
        }
        if (i === tokens.length) return new p.ParseReturn(true, root);
        else return new p.ParseReturn(false, null, 'does not consume all input tokens', 4);
    }
}

export default class LL1Parser {
    private _ptable: LL1ParseTable;
    private _prodset: prod.ProdSet;
    constructor(prodset: prod.ProdSet) {
        let ptable = new LL1ParseTable();
        let firstsets = prodset.firstSet(), followsets = prodset.followSet(), nullablenonterminals = prodset.nullableNonTerminals();
        for (let nont of prodset.getNonTerminals()) {
            let follow = followsets.get(nont);
            ptable.initRow(nont);
            for (let rsymarr of prodset.getRHSArr(nont)) {
                let gonull = true, idx = 0, syms = new Set<string>();
                while (idx < rsymarr.length && gonull) {
                    let rsym = rsymarr[idx];
                    let rname = rsym.getName();
                    gonull = nullablenonterminals.has(rname);
                    for (let f of firstsets.get(rname)) syms.add(f);
                    ++idx;
                }
                if (idx === rsymarr.length && gonull) {
                    for (let f of follow) syms.add(f);
                }
                ptable.addRange(nont, syms, rsymarr);
            }
        }
        this._ptable = ptable;
        this._prodset = prodset;
    }
    valid(): boolean { return this._ptable.valid(); }
    parse(tokens: Array<p.Token>): p.ParseReturn {
        return this._ptable.parse(tokens, this._prodset.getStartNonTerminal());
    }
    getParseRow(nont: string): Map<string, Array<Array<prod.Symbol>>> {
        return this._ptable.getParseRow(nont);
    }
    getProduction(nont: string, termi: string): Array<Array<prod.Symbol>> {
        return this._ptable.getProduction(nont, termi);
    }
    getSingleProduction(nont: string, termi: string): Array<prod.Symbol> {
        return this._ptable.getSingleProduction(nont, termi);
    }
    print(): this {
        this._ptable.print();
        return this;
    }
}