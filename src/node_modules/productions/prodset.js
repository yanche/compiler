
var utility = require('utility');

//prods: array of production
var ProdSet = function (prods) {
    if (prods.length === 0) throw new Error('empty prods input is not allowed');

    var pmap = new utility.MapOfArr(); //lhs->[rhs]
    var nonterminalset = new Set(), terminalset = new Set();
    var prodset = new Set(), startnonterminal = null;
    for (var p = 0; p < prods.length; ++p) {
        var production = prods[p];
        var prodid = production.getStrId();
        if (prodset.has(prodid)) throw new Error('dup production: ' + prodid);
        prodset.add(prodid);
        var lname = production.getLHS().getName();
        if (p === 0) startnonterminal = lname;
        var rhs = production.getRHS();
        pmap.add(lname, rhs);
        rhs.forEach(function (sym) { (sym.isTerminal() ? terminalset : nonterminalset).add(sym.getName()); });
        nonterminalset.add(lname);
    }

    if (pmap.getSize() !== nonterminalset.size) throw new Error('not all non-terminal symbol appears at LHS');

    this._productions = pmap;
    this._nonterminalset = nonterminalset;
    this._terminalset = terminalset;
    this._prodset = prodset; //string of production id
    this._startnonterminal = startnonterminal;
};
//return array of string (non-terminal symbol)
ProdSet.prototype.getAllNonTerminals = function () {
    return [...this._nonterminalset];
};
ProdSet.prototype.getAllTerminals = function () {
    return [...this._terminalset];
};
//input: string of LHS
//return: array of {array of Symbol}
ProdSet.prototype.getRHSArr = function (lhs_str) {
    return this._productions.get(lhs_str);
};
ProdSet.prototype.print = function () {
    [...this._prodset].forEach(str => console.log(str));
};
//return an map of symbol in string -> Set
ProdSet.prototype.firstSet = function () {
    var epsilonLHS = this.nullableNonTerminals(), ret = new utility.MapOfSet();
    var nodenummap = new NodeNumMap(new utility.IdGen());
    var edges = [], nonterminals = this.getAllNonTerminals();
    nonterminals.forEach(lstr => {
        if (epsilonLHS.has(lstr)) ret.add(lstr, '');
        this.getRHSArr(lstr).forEach(rhs => {
            var genepsilon = true, loc = 0;
            while (loc < rhs.length && genepsilon) {
                var rsymbol = rhs[loc];
                var rname = rsymbol.getName();
                if (rsymbol.isTerminal()) {
                    ret.add(lstr, rname);
                    genepsilon = false;
                }
                else {
                    var lnum = nodenummap.getOrCreateNum(lstr), rnum = nodenummap.getOrCreateNum(rname);
                    edges.push([lnum, rnum]); //could have dup edges, does not matter
                    genepsilon = epsilonLHS.has(rname);
                    ++loc;
                }
            }
        });
    });
    var closuremap = utility.calcClosure(edges);
    MergeClosureSet(nonterminals, nodenummap, closuremap, ret);
    this.getAllTerminals().forEach(tsym => ret.add(tsym, tsym));
    return ret.toMap();
};
ProdSet.prototype.followSet = function () {
    var ret = new utility.MapOfSet(), firstSets = this.firstSet();
    var nodenummap = new NodeNumMap(new utility.IdGen()), edges = [];
    var nonterminals = this.getAllNonTerminals();
    ret.add(this._startnonterminal, '$');
    nonterminals.forEach(lstr => {
        this.getRHSArr(lstr).forEach(rhs => {
            if (rhs.length === 0) return;
            var i = 1, j = 0;
            while (i < rhs.length) {
                var fset = firstSets.get(rhs[i].getName());
                var firsts = [...fset];
                var s = j;
                while (s < i) ret.addRange(rhs[s++].getName(), firsts);
                if (!fset.has('')) j = i;
                ++i;
            }
            //here i equals rhs.length
            var lnum = nodenummap.getOrCreateNum(lstr);
            while (j < i) {
                var rnum = nodenummap.getOrCreateNum(rhs[j].getName());
                if (rnum !== lnum) edges.push([rnum, lnum]);
                ++j;
            }
        });
    });
    var closuremap = utility.calcClosure(edges);
    MergeClosureSet(nonterminals, nodenummap, closuremap, ret);
    MergeClosureSet(this.getAllTerminals(), nodenummap, closuremap, ret);
    return ret.toMap();
};
//return an set of LHS(string), which could produce epsilon
ProdSet.prototype.nullableNonTerminals = function () {
    var map = new utility.MapOfArr(), retset = new Set(), queue = [];
    this.getAllNonTerminals().forEach(lstr => {
        var rhsarr = this.getRHSArr(lstr);
        for (var r = 0; r < rhsarr.length; ++r) {
            var rhs = rhsarr[r];
            if (rhs.length === 0) {
                if (!retset.has(lstr)) {
                    retset.add(lstr);
                    queue.push(lstr);
                }
                break;
            }
            if (rhs[0].isTerminal()) continue;
            map.add(rhs[0].getName(), { rhs: rhs, next: 1, lstr: lstr });
        }
    });
    while (queue.length > 0) {
        var lstr = queue.pop();
        (map.get(lstr) || []).forEach(ditem => {
            if (retset.has(ditem.lstr)) return;
            var next = ditem.next;
            while (next < ditem.rhs.length && retset.has(ditem.rhs[next].getName()))++next;
            if (next === ditem.rhs.length) {
                retset.add(ditem.lstr);
                queue.push(ditem.lstr);
            }
            else {
                var symbol = ditem.rhs[next];
                if (symbol.isTerminal()) return;
                map.add(symbol.getName(), { rhs: ditem.rhs, next: next + 1, lstr: ditem.lstr });
            }
        });
    }
    return retset;
};

//utility class
var NodeNumMap = function (idGen) {
    this._nodenummap = new Map();
    this._numnodemap = new Map();
    this._idGen = idGen;
};
NodeNumMap.prototype.getOrCreateNum = function (node) {
    var num = this._nodenummap.get(node);
    if (num == null) {
        num = this._idGen.newId();
        this._nodenummap.set(node, num);
        this._numnodemap.set(num, node);
    }
    return num;
}
NodeNumMap.prototype.getNode = function (num) {
    return this._numnodemap.get(num);
};

var MergeClosureSet = function (symstrarr, nodenummap, closuremap, retset) {
    symstrarr.forEach(str => {
        var snum = nodenummap.getOrCreateNum(str);
        var closure = closuremap.get(snum);
        if (closure == null) return;
        closure.getNodes().forEach(num => {
            if (num === snum) return;
            var symset = retset.get(nodenummap.getNode(num));
            if (symset == null) return;
            [...symset].forEach(s => retset.add(str, s));
        });
    });
};

module.exports = ProdSet;
