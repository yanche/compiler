
var utility = require('utility');

//prods: array of production
var ProdSet = function (prods) {
    var pmap = new Map(); //lhs->[rhs]
    var nonterminalset = new Set(), terminalset = new Set();
    for (var p = 0; p < prods.length; ++p) {
        var production = prods[p];
        var lhs = production.getLHS();
        var lname = lhs.getName();
        var rhs = production.getRHS();
        var rhsid = production.getRHSId();
        nonterminalset.add(lname);
        if (pmap.has(lname)) {
            var rhsarr = pmap.get(lname);
            if (rhsarr.every(function (rhs) { return rhs.id != rhsid; })) {
                rhsarr.push({ rhs: rhs, id: rhsid });
            }
        }
        else {
            pmap.set(lname, [{ rhs: rhs, id: rhsid }]);
        }
        for (var r = 0; r < rhs.length; ++r) {
            var symbol = rhs[r];
            if (symbol.isTerminal())
                terminalset.add(symbol.getName());
            else
                nonterminalset.add(symbol.getName());
        }
    }

    if (pmap.size !== nonterminalset.size) throw new Error('not all non-terminal symbol appears at LHS');

    this._productions = pmap;
    this._nonterminalset = nonterminalset;
    this._terminalset = terminalset;
};
//return array of string (non-terminal symbol)
ProdSet.prototype.getAllNonTerminals = function () {
    return [...this._nonterminalset];
};
ProdSet.prototype.getAllTerminals = function () {
    return [...this._terminalset];
};
//input: string of LHS
//return: array of {array of Symbol}
ProdSet.prototype.getRHS = function (lhs_str) {
    return this._productions.get(lhs_str).map(function (r) { return r.rhs });
};
ProdSet.prototype.print = function () {
    var all = [...this._productions];
    for (var i = 0; i < all.length; ++i) {
        var pair = all[i];
        var lhsname = pair[0];
        var rhsarr = pair[1];
        for (var p = 0; p < rhsarr.length; ++p)
            console.log([lhsname, '->', rhsarr[p].id].join(' '));
    }
    return this;
};
//return an array of {symbol:, firstSet: Set }
ProdSet.prototype.firstSet = function () {
    var prods = [...this._productions], epsilonLHS = this.nullableLHS();
    var ret = new utility.MapOfSet();
    var nodenummap = new Map(), idGen = new utility.IdGen();
    var numnodemap = new Map();
    var edges = [];
    for (var i = 0; i < prods.length; ++i) {
        var prod = prods[i];
        var lhs = prod[0], rhsarr = prod[1];
        if (epsilonLHS.has(lhs)) ret.add(lhs, '');
        for (var r = 0; r < rhsarr.length; ++r) {
            var loc = 0, rhs = rhsarr[r].rhs; //array of symbols
            var genepsilon = true;
            while (loc < rhs.length && genepsilon) {
                var rsymbol = rhs[loc];
                var rname = rsymbol.getName();
                if (rsymbol.isTerminal()) {
                    ret.add(lhs, rname);
                    genepsilon = false;
                }
                else {
                    var lnum = nodenummap.get(lhs), rnum = nodenummap.get(rname);
                    if (lnum == null) {
                        lnum = idGen.newId();
                        nodenummap.set(lhs, lnum);
                        numnodemap.set(lnum, lhs);
                    }
                    if (rnum == null) {
                        rnum = idGen.newId();
                        nodenummap.set(rname, rnum);
                        numnodemap.set(rnum, rname);
                    }
                    edges.push([lnum, rnum]); //could have dup edges, does not matter
                    genepsilon = epsilonLHS.has(rname);
                    ++loc;
                }
            }
        }
    }
    var closuremap = utility.calcClosure(edges);
    var nonterminals = this.getAllNonTerminals();
    for (var a = 0; a < nonterminals.length; ++a) {
        var lhs = nonterminals[a];
        var lnum = nodenummap.get(lhs);
        var closure = closuremap.get(lnum);
        if (closure == null) continue;
        var closurenums = closure.getNodes();
        for (var c = 0; c < closurenums.length; ++c) {
            var num = closurenums[c];
            if (num === lnum) continue;
            var symstr = numnodemap.get(num);
            var symset = ret.get(symstr);
            if (symset == null) continue;
            var symarr = [...symset];
            for (var s = 0; s < symarr.length; ++s) {
                ret.add(lhs, symarr[s]);
            }
        }
    }

    var terminals = this.getAllTerminals(), retarr = [];
    for (var t = 0; t < terminals.length; ++t)
        retarr.push({ symbol: terminals[t], firstSet: new Set().add(terminals[t]) });
    for (var t = 0; t < nonterminals.length; ++t)
        retarr.push({ symbol: nonterminals[t], firstSet: ret.get(nonterminals[t]) });
    return retarr;
};
//return an array of LHS(string), which could produce epsilon
ProdSet.prototype.nullableLHS = function () {
    var prods = [...this._productions];
    var map = new utility.MapOfArr(), retset = new Set(), queue = [];
    for (var i = 0; i < prods.length; ++i) {
        var prod = prods[i];
        var lhs = prod[0], rhsarr = prod[1];
        for (var r = 0; r < rhsarr.length; ++r) {
            var rhs = rhsarr[r].rhs; //array of symbols
            if (rhs.length === 0) {
                if (!retset.has(lhs)) {
                    retset.add(lhs); //lhs->epsilon
                    queue.push(lhs);
                }
                break;
            }
            if (rhs[0].isTerminal()) continue;
            map.add(rhs[0].getName(), { rhs: rhs, next: 1, lhs: lhs });
        }
    }
    while (queue.length > 0) {
        var lhs = queue.pop();
        var dependRHS = map.get(lhs) || [];
        for (var d = 0; d < dependRHS.length; ++d) {
            var item = dependRHS[d];
            if (retset.has(item.lhs)) continue;
            var next = item.next;
            while (next < item.rhs.length && retset.has(item.rhs[next].getName()))++next;
            if (next === item.rhs.length) {
                retset.add(item.lhs);
                queue.push(item.lhs);
            }
            else {
                var symbol = item.rhs[next];
                if (symbol.isTerminal()) continue;
                map.add(symbol.getName(), { rhs: item.rhs, next: next + 1, lhs: item.lhs });
            }
        }
    }
    return retset;
};

module.exports = ProdSet;
