
var utility = require('utility');
var _ = require('lodash');
var Production = require('./production.js');
var Symbol = require('./symbol.js');

//prods: array of production
var ProdSet = function (prods) {
    if (prods.length === 0) throw new Error('empty prods input is not allowed');

    var pmap = new utility.MapOfArr(); //lhs->[rhs]
    var nonterminalset = new Set(), terminalset = new Set();
    var prodset = new Set(), startnonterminal = null;
    var reachedges = [], nodenummap = new NodeNumMap(new utility.IdGen());
    for (var p = 0; p < prods.length; ++p) {
        var production = prods[p];
        var prodid = production.getStrId();
        if (prodset.has(prodid)) throw new Error('dup production: ' + prodid);
        prodset.add(prodid);
        var lname = production.getLHS().getName();
        var lnum = nodenummap.getOrCreateNum(lname);
        if (p === 0) startnonterminal = lname;
        var rhs = production.getRHS();
        pmap.add(lname, rhs);
        rhs.forEach(function (sym) {
            var rname = sym.getName();
            if (sym.isTerminal()) terminalset.add(rname);
            else {
                nonterminalset.add(rname);
                reachedges.push([lnum, nodenummap.getOrCreateNum(rname)]);
            }
        });
        nonterminalset.add(lname);
    }

    if (pmap.getSize() !== nonterminalset.size) throw new Error('not all non-terminal symbol appears at LHS');
    if (utility.calcClosureOfOneNode(reachedges, nodenummap.getOrCreateNum(startnonterminal)).size != nonterminalset.size) throw new Error('not all non-terminals are reachable from start non-terminal symbol');

    this._productions = pmap;
    this._nonterminalset = nonterminalset;
    this._terminalset = terminalset;
    this._prodset = prodset; //string of production id
    this._startnonterminal = startnonterminal;
};
//return array of string (non-terminal symbol)
ProdSet.prototype.getAllNonTerminals = function () {
    return [...this._nonterminalset];
};
ProdSet.prototype.getAllTerminals = function () {
    return [...this._terminalset];
};
//input: string of LHS
//return: array of {array of Symbol}
ProdSet.prototype.getRHSArr = function (lhs_str) {
    return this._productions.get(lhs_str);
};
ProdSet.prototype.print = function () {
    [...this._prodset].forEach(str => console.log(str));
};
//return an map of symbol in string -> Set
ProdSet.prototype.firstSet = function () {
    var epsilonLHS = this.nullableNonTerminals(), ret = new utility.MapOfSet();
    var nodenummap = new NodeNumMap(new utility.IdGen());
    var edges = [], nonterminals = this.getAllNonTerminals();
    nonterminals.forEach(lstr => {
        if (epsilonLHS.has(lstr)) ret.add(lstr, '');
        this.getRHSArr(lstr).forEach(rhs => {
            var genepsilon = true, loc = 0;
            while (loc < rhs.length && genepsilon) {
                var rsymbol = rhs[loc];
                var rname = rsymbol.getName();
                if (rsymbol.isTerminal()) {
                    ret.add(lstr, rname);
                    genepsilon = false;
                }
                else {
                    var lnum = nodenummap.getOrCreateNum(lstr), rnum = nodenummap.getOrCreateNum(rname);
                    edges.push([lnum, rnum]); //could have dup edges, does not matter
                    genepsilon = epsilonLHS.has(rname);
                    ++loc;
                }
            }
        });
    });
    var closuremap = utility.calcClosure(edges);
    mergeClosureSet(nonterminals, nodenummap, closuremap, ret);
    this.getAllTerminals().forEach(tsym => ret.add(tsym, tsym));
    return ret.toMap();
};
//return an map of symbol in string -> Set
ProdSet.prototype.followSet = function () {
    var ret = new utility.MapOfSet(), firstSets = this.firstSet();
    var nodenummap = new NodeNumMap(new utility.IdGen()), edges = [];
    var nonterminals = this.getAllNonTerminals();
    ret.add(this._startnonterminal, '$');
    nonterminals.forEach(lstr => {
        this.getRHSArr(lstr).forEach(rhs => {
            if (rhs.length === 0) return;
            var i = 1, j = 0;
            while (i < rhs.length) {
                var fset = firstSets.get(rhs[i].getName());
                var firsts = [...fset].filter(str => str.length > 0); //epsilon move not been contained
                var s = j;
                while (s < i) ret.addRange(rhs[s++].getName(), firsts);
                if (!fset.has('')) j = i;
                ++i;
            }
            //here i equals rhs.length
            var lnum = nodenummap.getOrCreateNum(lstr);
            while (j < i) {
                var rnum = nodenummap.getOrCreateNum(rhs[j].getName());
                if (rnum !== lnum) edges.push([rnum, lnum]);
                ++j;
            }
        });
    });
    var closuremap = utility.calcClosure(edges);
    mergeClosureSet(nonterminals, nodenummap, closuremap, ret);
    mergeClosureSet(this.getAllTerminals(), nodenummap, closuremap, ret);
    return ret.toMap();
};
//return an set of LHS(string), which could produce epsilon
ProdSet.prototype.nullableNonTerminals = function () {
    var map = new utility.MapOfArr(), retset = new Set(), queue = [];
    this.getAllNonTerminals().forEach(lstr => {
        var rhsarr = this.getRHSArr(lstr);
        for (var r = 0; r < rhsarr.length; ++r) {
            var rhs = rhsarr[r];
            if (rhs.length === 0) {
                if (!retset.has(lstr)) {
                    retset.add(lstr);
                    queue.push(lstr);
                }
                break;
            }
            if (rhs[0].isTerminal()) continue;
            map.add(rhs[0].getName(), { rhs: rhs, next: 1, lstr: lstr });
        }
    });
    while (queue.length > 0) {
        var lstr = queue.pop();
        (map.get(lstr) || []).forEach(ditem => {
            if (retset.has(ditem.lstr)) return;
            var next = ditem.next;
            while (next < ditem.rhs.length && retset.has(ditem.rhs[next].getName()))++next;
            if (next === ditem.rhs.length) {
                retset.add(ditem.lstr);
                queue.push(ditem.lstr);
            }
            else {
                var symbol = ditem.rhs[next];
                if (symbol.isTerminal()) return;
                map.add(symbol.getName(), { rhs: ditem.rhs, next: next + 1, lstr: ditem.lstr });
            }
        });
    }
    return retset;
};
ProdSet.prototype.leftFactoredProdSet = function () {
    var prods = [], idGen = new utility.IdGen();
    var newnonterminalgen = function () { return ProdSet.preservedNonTerminalPrefix + idGen.newId(); };
    this.getAllNonTerminals().forEach(lstr => {
        leftFactoring(lstr, this.getRHSArr(lstr), 0, prods, newnonterminalgen);
    });
    return prods.length === this._prodset.size ? this : new ProdSet(prods);
};

var leftFactoring = function (lstr, rhsarr, lfidx, prods, newnonterminalgen) {
    var lfmap = new utility.MapOfArr(), gonull = false, lfset = new Set();
    rhsarr.forEach(rhs => {
        if (rhs.length === lfidx) gonull = true;
        else {
            var lfname = rhs[lfidx].getName();
            lfmap.add(lfname, rhs);
            lfset.add(lfname);
        }
    });
    var lsymbol = new Symbol(false, lstr);
    if (gonull) prods.push(new Production(lsymbol, []));
    [...lfset].forEach(lfname => {
        var rhsarr = lfmap.get(lfname);
        //has only one, no need to left factoring
        if (rhsarr.length === 1) prods.push(new Production(lsymbol, lfidx > 0 ? rhsarr[0].slice(lfidx) : rhsarr[0]));
        else {
            var goahead = false, i = 1, lfidx0 = lfidx;
            lfidx -= 1;
            do {
                lfidx += 1;
                i = 1;
                if (rhsarr[0].length > lfidx + 1) {
                    var anchor = rhsarr[0][lfidx + 1].getName();
                    while (i < rhsarr.length && (rhsarr[i].length > lfidx + 1) && rhsarr[i][lfidx + 1].getName() === anchor)++i;
                }
            } while (i === rhsarr.length)
            var newnonterminal = newnonterminalgen();
            prods.push(new Production(lsymbol, rhsarr[0].slice(lfidx0, lfidx + 1).concat(new Symbol(false, newnonterminal))));
            leftFactoring(newnonterminal, rhsarr, lfidx + 1, prods, newnonterminalgen);
        }
    });
};
ProdSet.preservedNonTerminalPrefix = 'D__';

//utility class
var NodeNumMap = function (idGen) {
    this._nodenummap = new Map();
    this._numnodemap = new Map();
    this._idGen = idGen;
};
NodeNumMap.prototype.getOrCreateNum = function (node) {
    var num = this._nodenummap.get(node);
    if (num == null) {
        num = this._idGen.newId();
        this._nodenummap.set(node, num);
        this._numnodemap.set(num, node);
    }
    return num;
}
NodeNumMap.prototype.getNode = function (num) {
    return this._numnodemap.get(num);
};

var mergeClosureSet = function (symstrarr, nodenummap, closuremap, retset) {
    symstrarr.forEach(str => {
        var snum = nodenummap.getOrCreateNum(str);
        var closure = closuremap.get(snum);
        if (closure == null) return;
        closure.getNodes().forEach(num => {
            if (num === snum) return;
            var symset = retset.get(nodenummap.getNode(num));
            if (symset == null) return;
            [...symset].forEach(s => retset.add(str, s));
        });
    });
};

module.exports = ProdSet;
