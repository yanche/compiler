
var utility = require('utility');

//prods: array of production
var ProdSet = function (prods) {
    var pmap = new utility.MapOfArr(); //lhs->[rhs]
    var nonterminalset = new Set(), terminalset = new Set();
    var prodset = new Set();
    for (var p = 0; p < prods.length; ++p) {
        var production = prods[p];
        var prodid = production.getStrId();
        if (prodset.has(prodid)) throw new Error('dup production: ' + prodid);
        prodset.add(prodid);
        var lname = production.getLHS().getName();
        var rhs = production.getRHS();
        pmap.add(lname, rhs);
        rhs.forEach(function (sym) { (sym.isTerminal() ? terminalset : nonterminalset).add(sym.getName()); });
        nonterminalset.add(lname);
    }

    if (pmap.getSize() !== nonterminalset.size) throw new Error('not all non-terminal symbol appears at LHS');

    this._productions = pmap;
    this._nonterminalset = nonterminalset;
    this._terminalset = terminalset;
    this._prodset = prodset; //string of production id
};
//return array of string (non-terminal symbol)
ProdSet.prototype.getAllNonTerminals = function () {
    return [...this._nonterminalset];
};
ProdSet.prototype.getAllTerminals = function () {
    return [...this._terminalset];
};
//input: string of LHS
//return: array of {array of Symbol}
ProdSet.prototype.getRHSArr = function (lhs_str) {
    return this._productions.get(lhs_str);
};
ProdSet.prototype.print = function () {
    [...this._prodset].forEach(str => console.log(str));
};
//return an array of {symbol:, firstSet: Set }
ProdSet.prototype.firstSet = function () {
    var epsilonLHS = this.nullableNonTerminals(), ret = new utility.MapOfSet();
    var nodenummap = new Map(), numnodemap = new Map(), idGen = new utility.IdGen();
    var edges = [], nonterminals = this.getAllNonTerminals();

    nonterminals.forEach(lstr => {
        if (epsilonLHS.has(lstr)) ret.add(lstr, '');
        this.getRHSArr(lstr).forEach(rhs => {
            var genepsilon = true, loc = 0;
            while (loc < rhs.length && genepsilon) {
                var rsymbol = rhs[loc];
                var rname = rsymbol.getName();
                if (rsymbol.isTerminal()) {
                    ret.add(lstr, rname);
                    genepsilon = false;
                }
                else {
                    var lnum = nodenummap.get(lstr), rnum = nodenummap.get(rname);
                    if (lnum == null) {
                        lnum = idGen.newId();
                        nodenummap.set(lstr, lnum);
                        numnodemap.set(lnum, lstr);
                    }
                    if (rnum == null) {
                        rnum = idGen.newId();
                        nodenummap.set(rname, rnum);
                        numnodemap.set(rnum, rname);
                    }
                    edges.push([lnum, rnum]); //could have dup edges, does not matter
                    genepsilon = epsilonLHS.has(rname);
                    ++loc;
                }
            }
        });
    });
    var closuremap = utility.calcClosure(edges);

    nonterminals.forEach(lstr => {
        var lnum = nodenummap.get(lstr);
        var closure = closuremap.get(lnum);
        if (closure == null) return;
        closure.getNodes().forEach(num => {
            if (num === lnum) return;
            var symset = ret.get(numnodemap.get(num));
            if (symset == null) return;
            [...symset].forEach(s => ret.add(lstr, s));
        });
    });

    var retarr = [];
    this.getAllTerminals().forEach(tsym => retarr.push({ symbol: tsym, firstSet: new Set().add(tsym) }));
    nonterminals.forEach(lstr => retarr.push({ symbol: lstr, firstSet: ret.get(lstr) }));
    return retarr;
};
//return an set of LHS(string), which could produce epsilon
ProdSet.prototype.nullableNonTerminals = function () {
    var map = new utility.MapOfArr(), retset = new Set(), queue = [];
    this.getAllNonTerminals().forEach(lstr => {
        var rhsarr = this.getRHSArr(lstr);
        for (var r = 0; r < rhsarr.length; ++r) {
            var rhs = rhsarr[r];
            if (rhs.length === 0) {
                if (!retset.has(lstr)) {
                    retset.add(lstr);
                    queue.push(lstr);
                }
                break;
            }
            if (rhs[0].isTerminal()) continue;
            map.add(rhs[0].getName(), { rhs: rhs, next: 1, lstr: lstr });
        }
    });
    while (queue.length > 0) {
        var lstr = queue.pop();
        (map.get(lstr) || []).forEach(ditem => {
            if (retset.has(ditem.lstr)) return;
            var next = ditem.next;
            while (next < ditem.rhs.length && retset.has(ditem.rhs[next].getName()))++next;
            if (next === ditem.rhs.length) {
                retset.add(ditem.lstr);
                queue.push(ditem.lstr);
            }
            else {
                var symbol = ditem.rhs[next];
                if (symbol.isTerminal()) return;
                map.add(symbol.getName(), { rhs: ditem.rhs, next: next + 1, lstr: ditem.lstr });
            }
        });
    }
    return retset;
};

module.exports = ProdSet;
