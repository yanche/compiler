
import * as utility from 'utility';

class NodeNumMap {
    private _nodenummap: Map<string, number>;
    private _numnodemap: Map<number, string>;
    private _idGen: utility.IdGen;

    constructor() {
        this._nodenummap = new Map<string, number>();
        this._numnodemap = new Map<number, string>();
        this._idGen = new utility.IdGen();
    }
    getOrCreateNum(name: string): number {
        if (this._nodenummap.has(name)) return this._nodenummap.get(name);
        else {
            let id = this._idGen.next();
            this._nodenummap.set(name, id);
            this._numnodemap.set(id, name);
            return id;
        }
    }
    getNode(num: number): string {
        return this._numnodemap.get(num);
    }
}

export class Symbol {
    private _terminal: boolean;
    private _name: string;

    constructor(terminal: boolean, name: string) {
        if (name === '$') throw new Error('$ is reserved as a symbol');
        this._terminal = terminal;
        this._name = name;
    }
    isTerminal(): boolean { return this._terminal; }
    getName(): string { return this._name; }
}

export class Production {
    private _lhs: Symbol;
    private _rhs: Array<Symbol>;
    private _id: string;

    constructor(lhs: Symbol, rhs: Array<Symbol>) {
        if (lhs.isTerminal()) throw new Error('left-hand-side of production must be non-terminal');
        this._lhs = lhs;
        this._rhs = rhs || [];
        this._id = Production.id(this._lhs, this._rhs);
    }
    getLHS(): Symbol { return this._lhs; }
    getRHS(): Array<Symbol> { return this._rhs; }
    getId(): string { return this._id; }
    print(): this { console.log(this._id); return this; }
    static id(lhs: Symbol | string, rhs: Array<Symbol>) {
        let lstr: string;
        if (lhs instanceof Symbol) lstr = lhs.getName();
        else lstr = lhs;
        return lstr + ' -> ' + rhs.map(r => r.getName()).join(' ');
    }
}

export class ProdSet {
    private _startnonterminal: string;
    private _terminals: Set<string>;
    private _nonterminals: Set<string>;
    private _prodidset: Set<string>;
    private _prodmap: Map<string, Array<Array<Symbol>>>;
    private _nullableNonTerminals: Set<string>;
    private _firstSet: Map<string, Set<string>>;
    private _followSet: Map<string, Set<string>>;
    static preservedNonTerminalPrefix: string = 'D__';

    constructor(prods: Iterable<Production>) {
        let prodsize = 0, terminals = new Set<string>(), nonterminals = new Set<string>();
        let prodidset = new Set<string>(), nodenummap = new NodeNumMap(), prodmap = new Map<string, Array<Array<Symbol>>>();
        let startnonterminal: string = null, reachedges: Array<utility.Edge> = [];
        for (let prod of prods) {
            let prodid = prod.getId();
            if (prodidset.has(prodid)) throw new Error('duplicate production is not allowed: ' + prodid);
            prodidset.add(prodid);
            let lname = prod.getLHS().getName();
            let lnum = nodenummap.getOrCreateNum(lname);
            if (prodsize === 0) startnonterminal = lname;
            let rhs = prod.getRHS();
            addToMapOfArr(prodmap, lname, rhs);
            nonterminals.add(lname);
            for (let symbol of rhs) {
                let rname = symbol.getName();
                if (symbol.isTerminal()) terminals.add(rname);
                else {
                    nonterminals.add(rname);
                    reachedges.push({ src: lnum, tgt: nodenummap.getOrCreateNum(rname) });
                }
            }
            ++prodsize;
        }
        if (prodmap.size !== nonterminals.size) throw new Error('not all non-terminals appear at LHS');
        if (utility.closure.calcClosureOfOneNode(reachedges, nodenummap.getOrCreateNum(startnonterminal)).size !== nonterminals.size) throw new Error('some non-terminals are unreachable from start symbol');

        this._terminals = terminals;
        this._nonterminals = nonterminals;
        this._startnonterminal = startnonterminal;
        this._prodidset = prodidset;
        this._prodmap = prodmap;
    }
    getStartNonTerminal(): string { return this._startnonterminal; }
    getNonTerminals(): Set<string> { return this._nonterminals; }
    getTerminals(): Set<string> { return this._terminals; }
    getRHSArr(lhs: string): Array<Array<Symbol>> { return this._prodmap.get(lhs); }
    print(): this { for (let prodid of this._prodidset) console.log(prodid); return this; }
    firstSet(): Map<string, Set<string>> {
        if (this._firstSet != null) return this._firstSet;
        let nullablenont = this.nullableNonTerminals(), retmap = new Map<string, Set<string>>();
        let nodenummap = new NodeNumMap(), edges: Array<utility.Edge> = [], nonterminals = this.getNonTerminals();
        for (let nont of nonterminals) {
            retmap.set(nont, new Set<string>());
            for (let rsyms of this.getRHSArr(nont)) {
                let genepsilon = true, loc = 0;
                while (loc < rsyms.length && genepsilon) {
                    let rsym = rsyms[loc];
                    let rname = rsym.getName();
                    if (rsym.isTerminal()) {
                        addToMapOfSet(retmap, nont, rname);
                        genepsilon = false;
                    }
                    else {
                        let lnum = nodenummap.getOrCreateNum(nont), rnum = nodenummap.getOrCreateNum(rname);
                        edges.push({ src: lnum, tgt: rnum });
                        genepsilon = nullablenont.has(rname);
                        ++loc;
                    }
                }
            }
        }
        mergeClosureSet(nonterminals, nodenummap, utility.closure.calcClosure(edges), retmap);
        for (let t of this.getTerminals()) retmap.set(t, new Set<string>().add(t));
        this._firstSet = retmap;
        return retmap;
    }
    followSet(): Map<string, Set<string>> {
        if (this._followSet != null) return this._followSet;
        let retmap = new Map<string, Set<string>>(), firstSetMap = this.firstSet(), nullablenonterminals = this.nullableNonTerminals();
        let nodenummap = new NodeNumMap(), edges: Array<utility.Edge> = [], nonterminals = this.getNonTerminals();
        addToMapOfSet(retmap, this._startnonterminal, '$');
        for (let nont of nonterminals) {
            if (!retmap.has(nont)) retmap.set(nont, new Set<string>());
            for (let symarr of this.getRHSArr(nont)) {
                if (symarr.length === 0) continue;
                let i = 0, j = 0;
                while (i < symarr.length) {
                    let iname = symarr[i].getName();
                    let fset = firstSetMap.get(iname);
                    let s = j;
                    while (s < i) addRangeToMapOfSet(retmap, symarr[s++].getName(), fset);
                    if (!nullablenonterminals.has(iname)) j = i;
                    ++i;
                }
                let lnum = nodenummap.getOrCreateNum(nont);
                while (j < i) {
                    let rnum = nodenummap.getOrCreateNum(symarr[j].getName());
                    if (rnum != lnum) edges.push({ src: rnum, tgt: lnum });
                    ++j;
                }
            }
        }
        let clomap = utility.closure.calcClosure(edges);
        mergeClosureSet(nonterminals, nodenummap, clomap, retmap);
        mergeClosureSet(this.getTerminals(), nodenummap, clomap, retmap);
        this._followSet = retmap;
        return retmap;
    }
    nullableNonTerminals(): Set<string> {
        if (this._nullableNonTerminals != null) return this._nullableNonTerminals;
        let retset = new Set<string>(), queue: Array<string> = [];
        let map = new Map<string, Array<{ rsym: Array<Symbol>, next: number, lstr: string }>>();
        for (let nont of this.getNonTerminals()) {
            for (let rsym of this.getRHSArr(nont)) {
                if (rsym.length === 0) {
                    if (!retset.has(nont)) {
                        retset.add(nont);
                        queue.push(nont);
                    }
                    break;
                }
                if (rsym[0].isTerminal()) continue;
                addToMapOfArr(map, rsym[0].getName(), { rsym: rsym, next: 1, lstr: nont });
            }
        }
        while (queue.length > 0) {
            let lstr = queue.pop();
            for (let ditem of (map.get(lstr) || [])) {
                if (retset.has(ditem.lstr)) continue;
                let next = ditem.next;
                while (next < ditem.rsym.length && retset.has(ditem.rsym[next].getName()))++next;
                if (next === ditem.rsym.length) {
                    retset.add(ditem.lstr);
                    queue.push(ditem.lstr);
                }
                else {
                    let sym = ditem.rsym[next];
                    if (sym.isTerminal()) continue;
                    addToMapOfArr(map, sym.getName(), { rsym: ditem.rsym, next: next + 1, lstr: ditem.lstr });
                }
            }
        }
        this._nullableNonTerminals = retset;
        return retset;
    }
    leftFactoredProdSet(): ProdSet {
        let prods: Array<Production> = [], idgen = new utility.IdGen();
        for (var nont of this.getNonTerminals()) {
            leftFactoring(nont, this.getRHSArr(nont), 0, prods, idgen);
        }
        return prods.length === this._prodidset.size ? this : new ProdSet(prods);
    }
}

function leftFactoring(lstr: string, rhsarr: Array<Array<Symbol>>, lfidx: number, prods: Array<Production>, idGen: utility.IdGen) {
    var lfmap = new Map<string, Array<Array<Symbol>>>(), gonull = false, lfset = new Set<string>();
    for (let rsymarr of rhsarr) {
        if (rsymarr.length === lfidx) gonull = true;
        else {
            let lfname = rsymarr[lfidx].getName();
            addToMapOfArr(lfmap, lfname, rsymarr);
            lfset.add(lfname);
        }
    }
    let lsymbol = new Symbol(false, lstr);
    if (gonull) prods.push(new Production(lsymbol, []));
    for (let lfname of lfset) {
        let rights = lfmap.get(lfname);
        if (rights.length === 1) prods.push(new Production(lsymbol, lfidx > 0 ? rights[0].slice(lfidx) : rights[0]));
        else {
            let goahead = false, i = 1, lfidx0 = lfidx, anchor: string;
            lfidx -= 1;
            do {
                lfidx += 1;
                i = 1;
                if (rights[0].length > lfidx + 1) {
                    anchor = rights[0][lfidx + 1].getName();
                    while (i < rights.length && (rights[i].length > lfidx + 1) && rights[i][lfidx + 1].getName() === anchor)++i;
                }
            } while (i === rights.length)
            var newnont = ProdSet.preservedNonTerminalPrefix + idGen.next();
            prods.push(new Production(lsymbol, rights[0].slice(lfidx0, lfidx + 1).concat(new Symbol(false, newnont))));
            leftFactoring(newnont, rights, lfidx + 1, prods, idGen);
        }
    }
}

function addToMapOfArr<K, T>(map: Map<K, Array<T>>, key: K, item: T) {
    if (!map.has(key)) map.set(key, [item]);
    else map.get(key).push(item);
}

function addToMapOfSet<K, T>(map: Map<K, Set<T>>, key: K, item: T) {
    if (!map.has(key)) map.set(key, new Set<T>().add(item));
    else map.get(key).add(item);
}

function addRangeToMapOfSet<K, T>(map: Map<K, Set<T>>, key: K, item: Iterable<T>) {
    let set = map.get(key);
    if (set == null) {
        set = new Set<T>();
        map.set(key, set);
    }
    for (let s of item) set.add(s);
}

function mergeClosureSet(symstrarr: Iterable<string>, nodenummap: NodeNumMap, closuremap: Map<number, utility.closure.Closure>, map: Map<string, Set<string>>) {
    for (let str of symstrarr) {
        let snum = nodenummap.getOrCreateNum(str);
        let closure = closuremap.get(snum);
        if (closure == null) continue;
        for (let num of closure.getNodes()) {
            if (num === snum) continue;
            let symset = map.get(nodenummap.getNode(num));
            if (symset == null) return;
            for (let s of symset) addToMapOfSet(map, str, s);
        };
    };
}
