
//to be more precisely, it's productions of CFG (context free grammar)

var utility = require('utility');

//prods: array of production
var ProdSet = function (prods) {
    var pmap = new Map(); //lhs->[rhs]
    var nonterminalset = new Set(), terminalset = new Set();
    for (var p = 0; p < prods.length; ++p) {
        var production = prods[p];
        var lhs = production.getLHS();
        var lname = lhs.getName();
        var rhs = production.getRHS();
        var rhsid = production.getRHSId();
        nonterminalset.add(lname);
        if (pmap.has(lname)) {
            var rhsarr = pmap.get(lname);
            if (rhsarr.every(function (rhs) { return rhs.id != rhsid; })) {
                rhsarr.push({ rhs: rhs, id: rhsid });
            }
        }
        else {
            pmap.set(lname, [{ rhs: rhs, id: rhsid }]);
        }
        for (var r = 0; r < rhs.length; ++r) {
            var symbol = rhs[r];
            if (symbol.isTerminal())
                terminalset.add(symbol.getName());
            else
                nonterminalset.add(symbol.getName());
        }
    }

    if (pmap.size !== nonterminalset.size) throw new Error('not all non-terminal symbol appears at LHS');

    this._productions = pmap;
    this._nonterminalset = nonterminalset;
    this._terminalset = terminalset;
};
//return array of string (non-terminal symbol)
ProdSet.prototype.getAllNonTerminals = function () {
    return [...this._nonterminalset];
};
ProdSet.prototype.getAllTerminals = function () {
    return [...this._terminalset];
};
//input: string of LHS
//return: array of {array of Symbol}
ProdSet.prototype.getRHS = function (lhs_str) {
    return this._productions.get(lhs_str).map(function (r) { return r.rhs });
};
ProdSet.prototype.print = function () {
    var all = [...this._productions];
    for (var i = 0; i < all.length; ++i) {
        var pair = all[i];
        var lhsname = pair[0];
        var rhsarr = pair[1];
        for (var p = 0; p < rhsarr.length; ++p)
            console.log([lhsname, '->', rhsarr[p].id].join(' '));
    }
    return this;
};
//return an array of {symbol:, firstSet: Set }
ProdSet.prototype.firstSet = function () {
    var prods = [...this._productions], epsilonLHS = this.nullableLHS();
    var ret = new utility.MapOfSet();
    var nodenummap = new Map(), idGen = new utility.IdGen();
    var numnodemap = new Map();
    var edges = [];
    for (var i = 0; i < prods.length; ++i) {
        var prod = prods[i];
        var lhs = prod[0], rhsarr = prod[1];
        if (epsilonLHS.has(lhs)) ret.add(lhs, '');
        for (var r = 0; r < rhsarr.length; ++r) {
            var loc = 0, rhs = rhsarr[r].rhs; //array of symbols
            var genepsilon = true;
            while (loc < rhs.length && genepsilon) {
                var rsymbol = rhs[loc];
                var rname = rsymbol.getName();
                if (rsymbol.isTerminal()) {
                    ret.add(lhs, rname);
                    genepsilon = false;
                }
                else {
                    var lnum = nodenummap.get(lhs), rnum = nodenummap.get(rname);
                    if (lnum == null) {
                        lnum = idGen.newId();
                        nodenummap.set(lhs, lnum);
                        numnodemap.set(lnum, lhs);
                    }
                    if (rnum == null) {
                        rnum = idGen.newId();
                        nodenummap.set(rname, rnum);
                        numnodemap.set(rnum, rname);
                    }
                    edges.push([lnum, rnum]); //could have dup edges, does not matter
                    genepsilon = epsilonLHS.has(rname);
                    ++loc;
                }
            }
        }
    }
    var closuremap = utility.calcClosure(edges);
    var nonterminals = this.getAllNonTerminals();
    for (var a = 0; a < nonterminals.length; ++a) {
        var lhs = nonterminals[a];
        var lnum = nodenummap.get(lhs);
        var closure = closuremap.get(lnum);
        if (closure == null) continue;
        var closurenums = closure.getNodes();
        for (var c = 0; c < closurenums.length; ++c) {
            var num = closurenums[c];
            if (num === lnum) continue;
            var symstr = numnodemap.get(num);
            var symset = ret.get(symstr);
            if (symset == null) continue;
            var symarr = [...symset];
            for (var s = 0; s < symarr.length; ++s) {
                ret.add(lhs, symarr[s]);
            }
        }
    }

    var terminals = this.getAllTerminals(), retarr = [];
    for (var t = 0; t < terminals.length; ++t)
        retarr.push({ symbol: terminals[t], firstSet: new Set().add(terminals[t]) });
    for (var t = 0; t < nonterminals.length; ++t)
        retarr.push({ symbol: nonterminals[t], firstSet: ret.get(nonterminals[t]) });
    return retarr;
};
//return an array of LHS(string), which could produce epsilon
ProdSet.prototype.nullableLHS = function () {
    var prods = [...this._productions];
    var map = new utility.MapOfArr(), retset = new Set(), queue = [];
    for (var i = 0; i < prods.length; ++i) {
        var prod = prods[i];
        var lhs = prod[0], rhsarr = prod[1];
        for (var r = 0; r < rhsarr.length; ++r) {
            var rhs = rhsarr[r].rhs; //array of symbols
            if (rhs.length === 0) {
                if (!retset.has(lhs)) {
                    retset.add(lhs); //lhs->epsilon
                    queue.push(lhs);
                }
                break;
            }
            if (rhs[0].isTerminal()) continue;
            map.add(rhs[0].getName(), { rhs: rhs, next: 1, lhs: lhs });
        }
    }
    while (queue.length > 0) {
        var lhs = queue.pop();
        var dependRHS = map.get(lhs) || [];
        for (var d = 0; d < dependRHS.length; ++d) {
            var item = dependRHS[d];
            if (retset.has(item.lhs)) continue;
            var next = item.next;
            while (next < item.rhs.length && retset.has(item.rhs[next].getName()))++next;
            if (next === item.rhs.length) {
                retset.add(item.lhs);
                queue.push(item.lhs);
            }
            else {
                var symbol = item.rhs[next];
                if (symbol.isTerminal()) continue;
                map.add(symbol.getName(), { rhs: item.rhs, next: next + 1, lhs: item.lhs });
            }
        }
    }
    return retset;
};

//here the lhs is a non terminal and rhs is a list of terminal/non-terminals
var Production = function (lhs, rhs) {
    this._lhs = lhs; //symbol
    this._rhs = rhs || []; //array of symbols
    this._rhsid = this._rhs.map(function (rsymbol) { return rsymbol.getName(); }).join(' ');
};
Production.prototype.getLHS = function () {
    return this._lhs;
};
Production.prototype.getRHS = function () {
    return this._rhs;
};
Production.prototype.getRHSId = function () {
    return this._rhsid;
};
Production.prototype.print = function () {
    console.log(this._rhsid);
    return this;
};

//name: non-empty string, contains no space
var Symbol = function (terminal, name) {
    this._terminal = Boolean(terminal);
    this._name = name;
};
Symbol.prototype.isTerminal = function () {
    return this._terminal;
};
Symbol.prototype.getName = function () {
    return this._name;
};

// LHS -> RHS
// LHS contains only one non-terminal, RHS contains multiple symbols (terminal or non-terminal)
// terminal: string starts with non upper case letter character and contains no space
// non-terminal: string starts with upper case letter and contains no space
// RHS: use space to split each symbol
var createProduction = function (lstr, rstr) {
    if (!utility.isStr(lstr) || !utility.isStr(rstr)) throw new Error('lstr or rstr is not a string');
    lstr = lstr.trim();
    rstr = rstr.trim();
    if (lstr.length == 0) throw new Error('left hand of production is empty');
    if (lstr.indexOf(' ') >= 0) throw new Error('left hand of production must contains only one non-terminal symbol');
    if (!strAsNonTerminal(lstr)) throw new Error('left hand symbol is not a non-terminal');
    var lsymbol = new Symbol(false, lstr);
    var rsymbols = rstr.split(' ').filter(function (str) { return str.length > 0; }).map(function (str) {
        return new Symbol(!strAsNonTerminal(str), str);
    });
    //note: rsymbols could be empty array so that the rhs of production is epsilon
    return new Production(lsymbol, rsymbols);
};

var createProduction2 = function (prodstr) {
    if (!utility.isStr(prodstr)) throw new Error('prodstr is not a string: ' + prodstr);
    var idxLhs = prodstr.indexOf('->');
    if (idxLhs < 0) throw new Error('production must has a -> :' + prodstr);
    var lstr = str.slice(0, idxLhs).trim();
    var rstr = str.slice(idxLhs + 2).trim();
    return createProduction(lstr, rstr);
};

//separate multiple rhs by using |
var createProductions = function (multiprodstr) {
    if (!utility.isStr(multiprodstr)) throw new Error('multiprodstr is not a string: ' + multiprodstr);
    var idxLhs = multiprodstr.indexOf('->');
    if (idxLhs < 0) throw new Error('production must has a -> :' + multiprodstr);
    var lstr = multiprodstr.slice(0, idxLhs).trim();
    return multiprodstr.slice(idxLhs + 2).trim().split('|').map(function (r) { return createProduction(lstr, r); });
};

//array of multi-prod-str
var createProdSet = function (arrOfMPDS) {
    if (!Array.isArray(arrOfMPDS)) throw new Error('input is not an array');
    var allprods = [];
    for (var i = 0; i < arrOfMPDS.length; ++i) {
        var prods = createProductions(arrOfMPDS[i]);
        for (var j = 0; j < prods.length; ++j)
            allprods.push(prods[j]);
    }
    return new ProdSet(allprods);
};

var chA = 'A'.charCodeAt(0);
var chZ = 'Z'.charCodeAt(0);

//assume str contains no space and str.length > 0
var strAsNonTerminal = function (str) {
    var ch = str.charCodeAt(0);
    return chA <= ch && ch <= chZ;
};


exports.createProdSet = createProdSet;
