
//to be more precisely, it's productions of CFG (context free grammar)

var _ = require('lodash');
var utility = require('utility');

var ProdSet = require('./prodset.js');
var Production = require('./production.js');
var Symbol = require('./symbol.js');

// LHS -> RHS
// LHS contains only one non-terminal, RHS contains multiple symbols (terminal or non-terminal)
// terminal: string starts with non upper case letter character and contains no space
// non-terminal: string starts with upper case letter and contains no space
// RHS: use space to split each symbol
var createProduction = function (lstr, rstr) {
    if (!utility.isStr(lstr) || !utility.isStr(rstr)) throw new Error('lstr or rstr is not a string');
    lstr = lstr.trim();
    rstr = rstr.trim();
    if (lstr.length == 0) throw new Error('left hand of production is empty');
    if (lstr.indexOf(' ') >= 0) throw new Error('left hand of production must contains only one non-terminal symbol');
    if (!strAsNonTerminal(lstr)) throw new Error('left hand symbol is not a non-terminal');
    if (_.startsWith(lstr, ProdSet.preservedNonTerminalPrefix)) throw new Error('non-terminal cannot start with preserved prefix');
    var lsymbol = new Symbol(false, lstr);
    var rsymbols = rstr.split(' ').filter(function (str) { return str.length > 0; }).map(function (str) {
        if (_.startsWith(str, ProdSet.preservedNonTerminalPrefix)) throw new Error('non-terminal cannot start with preserved prefix');
        return new Symbol(!strAsNonTerminal(str), str);
    });
    //note: rsymbols could be empty array so that the rhs of production is epsilon
    return new Production(lsymbol, rsymbols);
};

var createProduction2 = function (prodstr) {
    if (!utility.isStr(prodstr)) throw new Error('prodstr is not a string: ' + prodstr);
    var idxLhs = prodstr.indexOf('->');
    if (idxLhs < 0) throw new Error('production must has a -> :' + prodstr);
    var lstr = str.slice(0, idxLhs).trim();
    var rstr = str.slice(idxLhs + 2).trim();
    return createProduction(lstr, rstr);
};

//separate multiple rhs by using |
var createProductions = function (multiprodstr) {
    if (!utility.isStr(multiprodstr)) throw new Error('multiprodstr is not a string: ' + multiprodstr);
    var idxLhs = multiprodstr.indexOf('->');
    if (idxLhs < 0) throw new Error('production must has a -> :' + multiprodstr);
    var lstr = multiprodstr.slice(0, idxLhs).trim();
    return multiprodstr.slice(idxLhs + 2).trim().split('|').map(function (r) { return createProduction(lstr, r); });
};

//array of multi-prod-str
var createProdSet = function (arrOfMPDS) {
    if (!Array.isArray(arrOfMPDS)) throw new Error('input is not an array');
    var prods = [];
    arrOfMPDS.forEach(mpds => createProductions(mpds).forEach(prod => prods.push(prod)));
    return new ProdSet(prods);
};

var chA = 'A'.charCodeAt(0);
var chZ = 'Z'.charCodeAt(0);

//assume str contains no space and str.length > 0
var strAsNonTerminal = function (str) {
    var ch = str.charCodeAt(0);
    return chA <= ch && ch <= chZ;
};


exports.createProdSet = createProdSet;
