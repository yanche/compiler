
//to be more precisely, it's productions of CFG (context free grammar)

var utility = require('utility');

var ProdSet = function () {
    this._productions = new Map(); //lhs->[rhs]
};
ProdSet.prototype.add = function (production) {
    var lhs = production.getLHS();
    var lname = lhs.getName();
    var rhs = production.getRHS();
    var rhsid = production.getRHSId();
    if (this._productions.has(lname)) {
        var rhsarr = this._productions.get(lname);
        if (rhsarr.every(function (rhs) { return rhs.id != rhsid; })) rhsarr.push({ rhs: rhs, id: rhsid });
        else throw new Error('the production already exists, cannot add it twice');
    }
    else {
        this._productions.set(lname, [{ rhs: rhs, id: rhsid }]);
    }
    return this;
};
//return array of string (non-terminal symbol)
ProdSet.prototype.getAllLHS = function () {
    return [...this._productions].map(function (p) { return p[0]; });
};
//input: string of LHS
//return: array of {array of Symbol}
ProdSet.prototype.getRHS = function (lhs_str) {
    return this._productions.get(lhs_str).map(function (r) { return r.rhs });
};
ProdSet.prototype.print = function () {
    var all = [...this._productions];
    for (var i = 0; i < all.length; ++i) {
        var pair = all[i];
        var lhsname = pair[0];
        var rhsarr = pair[1];
        for (var p = 0; p < rhsarr.length; ++p)
            console.log([lhsname, '->', rhsarr[p].id].join(' '));
    }
    return this;
};

//here the lhs is a non terminal and rhs is a list of terminal/non-terminals
var Production = function (lhs, rhs) {
    this._lhs = lhs; //symbol
    this._rhs = rhs || []; //array of symbols
    this._rhsid = this._rhs.map(function (rsymbol) { return rsymbol.getName(); }).join(' ');
};
Production.prototype.getLHS = function () {
    return this._lhs;
};
Production.prototype.getRHS = function () {
    return this._rhs;
};
Production.prototype.getRHSId = function () {
    return this._rhsid;
};
Production.prototype.print = function () {
    console.log(this._rhsid);
    return this;
};

//name: non-empty string, contains no space
var Symbol = function (terminal, name) {
    this._terminal = Boolean(terminal);
    this._name = name;
};
Symbol.prototype.isTerminal = function () {
    return this._terminal;
};
Symbol.prototype.getName = function () {
    return this._name;
};

// LHS -> RHS
// LHS contains only one non-terminal, RHS contains multiple symbols (terminal or non-terminal)
// terminal: string starts with non upper case letter character and contains no space
// non-terminal: string starts with upper case letter and contains no space
// RHS: use space to split each symbol
var createProduction = function (lstr, rstr) {
    if (!utility.isStr(lstr) || !utility.isStr(rstr)) throw new Error('lstr or rstr is not a string');
    lstr = lstr.trim();
    rstr = rstr.trim();
    if (lstr.length == 0) throw new Error('left hand of production is empty');
    if (lstr.indexOf(' ') >= 0) throw new Error('left hand of production must contains only one non-terminal symbol');
    if (!strAsNonTerminal(lstr)) throw new Error('left hand symbol is not a non-terminal');
    var lsymbol = new Symbol(false, lstr);
    var rsymbols = rstr.split(' ').filter(function (str) { return str.length > 0; }).map(function (str) {
        return new Symbol(!strAsNonTerminal(str), str);
    });
    //note: rsymbols could be empty array so that the rhs of production is epsilon
    return new Production(lsymbol, rsymbols);
};

var createProduction2 = function (prodstr) {
    if (!utility.isStr(prodstr)) throw new Error('prodstr is not a string: ' + prodstr);
    var idxLhs = prodstr.indexOf('->');
    if (idxLhs < 0) throw new Error('production must has a -> :' + prodstr);
    var lstr = str.slice(0, idxLhs).trim();
    var rstr = str.slice(idxLhs + 2).trim();
    return createProduction(lstr, rstr);
};

//separate multiple rhs by using |
var createProductions = function (multiprodstr) {
    if (!utility.isStr(multiprodstr)) throw new Error('multiprodstr is not a string: ' + multiprodstr);
    var idxLhs = multiprodstr.indexOf('->');
    if (idxLhs < 0) throw new Error('production must has a -> :' + multiprodstr);
    var lstr = multiprodstr.slice(0, idxLhs).trim();
    return multiprodstr.slice(idxLhs + 2).trim().split('|').map(function (r) { return createProduction(lstr, r); });
};

//array of multi-prod-str
var createProdSet = function (arrOfMPDS) {
    if (!Array.isArray(arrOfMPDS)) throw new Error('input is not an array');
    var pset = new ProdSet();
    for (var i = 0; i < arrOfMPDS.length; ++i) {
        var prods = createProductions(arrOfMPDS[i]);
        for (var j = 0; j < prods.length; ++j)
            pset.add(prods[j]);
    }
    return pset;
};

var chA = 'A'.charCodeAt(0);
var chZ = 'Z'.charCodeAt(0);

//assume str contains no space and str.length > 0
var strAsNonTerminal = function (str) {
    var ch = str.charCodeAt(0);
    return chA <= ch && ch <= chZ;
};


exports.createProdSet = createProdSet;
