"use strict";
const utility = require('utility');
const _ = require('lodash');
class Symbol {
    constructor(terminal, name) {
        if (name === '$')
            throw new Error('$ is reserved as a symbol');
        this._terminal = terminal;
        this._name = name;
    }
    isTerminal() { return this._terminal; }
    getName() { return this._name; }
}
exports.Symbol = Symbol;
class Production {
    constructor(lhs, rhs) {
        if (lhs.isTerminal())
            throw new Error('left-hand-side of production must be non-terminal');
        this._lhs = lhs;
        this._rhs = rhs || [];
        this._literal = Production.id(this._lhs, this._rhs);
    }
    getLHS() { return this._lhs; }
    getRHS() { return this._rhs; }
    getLiteral() { return this._literal; }
    print() { console.log(this._literal); return this; }
    static id(lhs, rhs) {
        let lstr;
        if (lhs instanceof Symbol)
            lstr = lhs.getName();
        else
            lstr = lhs;
        return lstr + ' -> ' + rhs.map(r => r.getName()).join(' ');
    }
}
exports.Production = Production;
class ProdSet {
    constructor(prods) {
        let termict = 0, nonterminals = new Set(), symnummap = new utility.BidirectMap();
        let numprodmap = new Map(), nontprodmap = new Map();
        let prodliteralset = new Set(), startnontnum, reachedges = [], prodidgen = new utility.IdGen();
        symnummap.getOrCreateNum('$');
        for (let prod of prods) {
            let prodliteral = prod.getLiteral();
            if (prodliteralset.has(prodliteral))
                throw new Error('duplicate production is not allowed: ' + prodliteral);
            prodliteralset.add(prodliteral);
            nonterminals.add(prod.getLHS().getName());
            for (let sym of prod.getRHS()) {
                if (sym.isTerminal())
                    symnummap.getOrCreateNum(sym.getName());
                else
                    nonterminals.add(sym.getName());
            }
        }
        termict = symnummap.size;
        for (let nont of nonterminals)
            symnummap.getOrCreateNum(nont);
        for (let prod of prods) {
            let lnum = symnummap.getNum(prod.getLHS().getName()), rhs = prod.getRHS(), prodid = prodidgen.next();
            if (startnontnum == null)
                startnontnum = lnum;
            numprodmap.set(prodid, {
                prod: prod, lnum: lnum, rnums: rhs.map(s => {
                    let rnum = symnummap.getNum(s.getName());
                    if (!s.isTerminal())
                        reachedges.push({ src: lnum, tgt: rnum });
                    return rnum;
                })
            });
            addToMapOfArr(nontprodmap, lnum, prodid);
        }
        if (nontprodmap.size !== nonterminals.size)
            throw new Error('not all non-terminals appear at LHS');
        if (utility.closure.calcClosureOfOneNode(reachedges, startnontnum).size !== nonterminals.size)
            throw new Error('some non-terminals are unreachable from start symbol');
        this._startnontnum = startnontnum;
        this._prodliteralset = prodliteralset;
        this._nontprodmap = nontprodmap;
        this._numprodmap = numprodmap;
        this._symnummap = symnummap;
        this._termict = termict;
        this._totalsymct = symnummap.size;
    }
    getStartNonTerminal() { return this._startnontnum; }
    getStartNonTerminalInStr() { return this.getSymInStr(this.getStartNonTerminal()); }
    getAllSymNums() { return _.range(1, this._totalsymct + 1); }
    getNonTerminals() { return _.range(this._termict + 1, this._totalsymct + 1); }
    getNonTerminalsInStr() { return this.getNonTerminals().map(n => this.getSymInStr(n)); }
    getTerminals() { return _.range(1, this._termict + 1); }
    getTerminalsInStr() { return this.getTerminals().map(n => this.getSymInStr(n)); }
    getSymInStr(num) { return this._symnummap.getT(num); }
    getSymNum(sym) { return this._symnummap.getNum(sym); }
    isSymNumTerminal(num) { return num <= this._termict; }
    getProds(lsymnum) { return this._nontprodmap.get(lsymnum); }
    getProdRef(prodnum) { return this._numprodmap.get(prodnum); }
    getProdSize() { return this._numprodmap.size; }
    print() { for (let prodliteral of this._prodliteralset)
        console.log(prodliteral); return this; }
    firstSet() {
        if (this._firstSet != null)
            return this._firstSet;
        let nullablenont = this.nullableNonTerminals(), retmap = new Map();
        let edges = [], nonterminals = this.getNonTerminals();
        for (let nont of nonterminals) {
            retmap.set(nont, new Set());
            for (let prodid of this.getProds(nont)) {
                let prodref = this.getProdRef(prodid);
                let genepsilon = true, loc = 0;
                while (loc < prodref.rnums.length && genepsilon) {
                    let rnum = prodref.rnums[loc];
                    if (this.isSymNumTerminal(rnum)) {
                        addToMapOfSet(retmap, nont, rnum);
                        genepsilon = false;
                    }
                    else {
                        edges.push({ src: nont, tgt: rnum });
                        genepsilon = nullablenont.has(rnum);
                        ++loc;
                    }
                }
            }
        }
        mergeClosureSet(nonterminals, utility.closure.calcClosure(edges), retmap);
        for (let t of this.getTerminals())
            retmap.set(t, new Set().add(t));
        this._firstSet = retmap;
        return retmap;
    }
    followSet() {
        if (this._followSet != null)
            return this._followSet;
        let retmap = new Map(), firstSetMap = this.firstSet(), nullablenonterminals = this.nullableNonTerminals(), edges = [];
        addToMapOfSet(retmap, this._startnontnum, 0);
        for (let nont of this.getNonTerminals()) {
            if (!retmap.has(nont))
                retmap.set(nont, new Set());
            for (let prodid of this.getProds(nont)) {
                let rnums = this.getProdRef(prodid).rnums;
                if (rnums.length === 0)
                    continue;
                let i = 1, j = 0;
                while (i < rnums.length) {
                    let rnum = rnums[i];
                    let fset = firstSetMap.get(rnum);
                    let s = j;
                    while (s < i)
                        addRangeToMapOfSet(retmap, rnums[s++], fset);
                    if (!nullablenonterminals.has(rnum))
                        j = i;
                    ++i;
                }
                while (j < i) {
                    let rnum = rnums[j];
                    if (rnum != nont)
                        edges.push({ src: rnum, tgt: nont });
                    ++j;
                }
            }
        }
        let clomap = utility.closure.calcClosure(edges);
        mergeClosureSet(this.getAllSymNums(), clomap, retmap);
        this._followSet = retmap;
        return retmap;
    }
    nullableNonTerminalsInStr() {
        return [...this.nullableNonTerminals()].map(n => this.getSymInStr(n));
    }
    nullableNonTerminals() {
        if (this._nullableNonTerminals != null)
            return this._nullableNonTerminals;
        let retset = new Set(), queue = [];
        let map = new Map();
        for (let nont of this.getNonTerminals()) {
            for (let prodid of this.getProds(nont)) {
                let rnums = this.getProdRef(prodid).rnums;
                if (rnums.length === 0) {
                    if (!retset.has(nont)) {
                        retset.add(nont);
                        queue.push(nont);
                    }
                    break;
                }
                if (this.isSymNumTerminal(rnums[0]))
                    continue;
                addToMapOfArr(map, rnums[0], { rnums: rnums, next: 1, lnum: nont });
            }
        }
        while (queue.length > 0) {
            let lnum = queue.pop();
            for (let ditem of (map.get(lnum) || [])) {
                if (retset.has(ditem.lnum))
                    continue;
                let next = ditem.next;
                while (next < ditem.rnums.length && retset.has(ditem.rnums[next]))
                    ++next;
                if (next === ditem.rnums.length) {
                    retset.add(ditem.lnum);
                    queue.push(ditem.lnum);
                }
                else {
                    let symnum = ditem.rnums[next];
                    if (this.isSymNumTerminal(symnum))
                        continue;
                    addToMapOfArr(map, symnum, { rnums: ditem.rnums, next: next + 1, lnum: ditem.lnum });
                }
            }
        }
        this._nullableNonTerminals = retset;
        return retset;
    }
    leftFactoredProdSet() {
        let prods = [], idgen = new utility.IdGen();
        for (var nont of this.getNonTerminals()) {
            leftFactoring(this.getSymInStr(nont), this.getProds(nont).map(p => this.getProdRef(p)).map(p => p.prod.getRHS()), 0, prods, idgen);
        }
        return prods.length === this._prodliteralset.size ? this : new ProdSet(prods);
    }
}
ProdSet.preservedNonTerminalPrefix = 'D__';
exports.ProdSet = ProdSet;
function leftFactoring(lstr, rhsarr, lfidx, prods, idGen) {
    var lfmap = new Map(), gonull = false, lfset = new Set();
    for (let rsymarr of rhsarr) {
        if (rsymarr.length === lfidx)
            gonull = true;
        else {
            let lfname = rsymarr[lfidx].getName();
            addToMapOfArr(lfmap, lfname, rsymarr);
            lfset.add(lfname);
        }
    }
    let lsymbol = new Symbol(false, lstr);
    if (gonull)
        prods.push(new Production(lsymbol, []));
    for (let lfname of lfset) {
        let rights = lfmap.get(lfname);
        if (rights.length === 1)
            prods.push(new Production(lsymbol, lfidx > 0 ? rights[0].slice(lfidx) : rights[0]));
        else {
            let goahead = false, i = 1, lfidx0 = lfidx, anchor;
            lfidx -= 1;
            do {
                lfidx += 1;
                i = 1;
                if (rights[0].length > lfidx + 1) {
                    anchor = rights[0][lfidx + 1].getName();
                    while (i < rights.length && (rights[i].length > lfidx + 1) && rights[i][lfidx + 1].getName() === anchor)
                        ++i;
                }
            } while (i === rights.length);
            var newnont = ProdSet.preservedNonTerminalPrefix + idGen.next();
            prods.push(new Production(lsymbol, rights[0].slice(lfidx0, lfidx + 1).concat(new Symbol(false, newnont))));
            leftFactoring(newnont, rights, lfidx + 1, prods, idGen);
        }
    }
}
function addToMapOfArr(map, key, item) {
    if (!map.has(key))
        map.set(key, [item]);
    else
        map.get(key).push(item);
}
function addToMapOfSet(map, key, item) {
    if (!map.has(key))
        map.set(key, new Set().add(item));
    else
        map.get(key).add(item);
}
function addRangeToMapOfSet(map, key, item) {
    let set = map.get(key);
    if (set == null) {
        set = new Set();
        map.set(key, set);
    }
    for (let s of item)
        set.add(s);
}
function mergeClosureSet(symnums, closuremap, map) {
    for (let symnum of symnums) {
        let closure = closuremap.get(symnum);
        if (closure == null)
            continue;
        for (let num of closure.getNodes()) {
            if (num === symnum)
                continue;
            let symset = map.get(symnum);
            if (symset == null)
                return;
            for (let s of symset)
                addToMapOfSet(map, symnum, s);
        }
        ;
    }
    ;
}
//# sourceMappingURL=production.js.map