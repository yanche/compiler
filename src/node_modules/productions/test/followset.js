"use strict";
const assert = require('assert');
const utility = require('utility');
const index_1 = require('../index');
function validate(prodset, expected) {
    assert.equal(true, utility.arrayEquivalent([...prodset.followSet()], expected, function (f, e) {
        return f[0] === prodset.getSymNum(e.symbol) && utility.arrayEquivalent([...f[1]], e.follow.map(x => prodset.getSymNum(x)));
    }));
}
;
describe('follow sets', function () {
    it('simple 1', function () {
        let pset = index_1.createProdSet([
            'E -> T + E | T',
            'T -> int | int * T | ( E )'
        ]);
        validate(pset, [
            { symbol: 'E', follow: ['$', ')'] },
            { symbol: 'T', follow: ['$', ')', '+'] },
            { symbol: '(', follow: ['int', '('] },
            { symbol: ')', follow: ['$', ')', '+'] },
            { symbol: '+', follow: ['int', '('] },
            { symbol: '*', follow: ['int', '('] },
            { symbol: 'int', follow: ['$', ')', '+', '*'] }
        ]);
    });
    it('simple 2', function () {
        let pset = index_1.createProdSet([
            'E -> '
        ]);
        validate(pset, [
            { symbol: 'E', follow: ['$'] }
        ]);
    });
    it('simple 3', function () {
        let pset = index_1.createProdSet([
            'T -> E | int',
            'E -> '
        ]);
        validate(pset, [
            { symbol: 'E', follow: ['$'] },
            { symbol: 'T', follow: ['$'] },
            { symbol: 'int', follow: ['$'] }
        ]);
    });
});
//# sourceMappingURL=followset.js.map