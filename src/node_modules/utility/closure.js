"use strict";
class Closure {
    constructor() {
        this._set = new Set();
        this._owners = new Set();
    }
    addNode(nodenum) {
        this._set.add(nodenum);
        return this;
    }
    addOwnerNode(nodenum) {
        this._owners.add(nodenum);
        return this;
    }
    getNodes() {
        return this._set;
    }
    getOwnerNodes() {
        return this._owners;
    }
}
exports.Closure = Closure;
function createGraph(arr) {
    let map = new Map(), allnodes = new Set();
    for (let edge of arr) {
        let srcnum = edge.src, tgtnum = edge.tgt;
        let edgeset = map.get(srcnum);
        if (edgeset == null) {
            edgeset = new Set();
            map.set(srcnum, edgeset);
        }
        edgeset.add(tgtnum);
        allnodes.add(tgtnum);
        allnodes.add(srcnum);
    }
    return { nodes: allnodes, edgemap: map };
}
function calcClosure(graph) {
    let colormap = new Map(), closuremap = new Map(), nlen = graph.nodes.size;
    if (nlen === 0)
        return closuremap;
    for (let i of graph.nodes)
        colormap.set(i, 0);
    let blackidx = 0, nodenums = [...graph.nodes];
    while (blackidx < nlen) {
        calcClosureOfNode([], 0, nodenums[blackidx], colormap, graph.edgemap, closuremap);
        while (blackidx < nlen && colormap.get(nodenums[blackidx]) === 2)
            ++blackidx;
    }
    return closuremap;
}
function calcClosureOfNode(stack, stacktop, nodenum, colormap, edgesmap, closuremap) {
    stack[stacktop] = nodenum;
    addNodesToClosure(stack, 0, stacktop, [nodenum], closuremap);
    colormap.set(nodenum, 1);
    let edgeset = edgesmap.get(nodenum);
    if (edgeset != null) {
        for (let adjnodenum of [...edgeset]) {
            if (adjnodenum === nodenum)
                continue;
            let adjcolor = colormap.get(adjnodenum), adjclosure = closuremap.get(adjnodenum);
            if (adjcolor === 2)
                addNodesToClosure(stack, 0, stacktop, adjclosure.getNodes(), closuremap);
            else if (adjcolor === 1) {
                let adjidx = 0;
                while (adjidx <= stacktop && stack[adjidx] !== adjnodenum)
                    ++adjidx;
                ++adjidx;
                while (adjidx <= stacktop) {
                    let processedowners = new Set();
                    for (let ownernodenum of closuremap.get(stack[adjidx++]).getOwnerNodes()) {
                        if (!processedowners.has(ownernodenum)) {
                            closuremap.set(ownernodenum, adjclosure);
                            adjclosure.addOwnerNode(ownernodenum);
                            processedowners.add(ownernodenum);
                        }
                    }
                }
            }
            else
                calcClosureOfNode(stack, stacktop + 1, adjnodenum, colormap, edgesmap, closuremap);
        }
    }
    colormap.set(nodenum, 2);
}
function addNodesToClosure(nodearr, s, e, closurenodenums, closuremap) {
    while (s <= e) {
        let snodenum = nodearr[s];
        let closure = closuremap.get(snodenum);
        if (closure == null) {
            closure = new Closure();
            closure.addOwnerNode(snodenum);
            closuremap.set(snodenum, closure);
        }
        for (let i of closurenodenums)
            closure.addNode(i);
        ++s;
    }
}
function ex_calcClosure(arr) {
    return calcClosure(createGraph(arr));
}
exports.calcClosure = ex_calcClosure;
function closureOfNodes(nodenums, closuremap) {
    let ret = new Set();
    for (let nodenum of nodenums) {
        for (let cnodenum of closuremap.get(nodenum).getNodes())
            ret.add(cnodenum);
    }
    return ret;
}
exports.closureOfNodes = closureOfNodes;
function calcClosureOfOneNode(edgemap, nodenum) {
    let set = new Set().add(nodenum), queue = [nodenum];
    while (queue.length > 0) {
        let nnum = queue.pop();
        let adjset = edgemap.get(nnum);
        if (adjset == null)
            continue;
        for (let adjnum of adjset) {
            if (!set.has(adjnum)) {
                set.add(adjnum);
                queue.push(adjnum);
            }
        }
    }
    return set;
}
;
function ex_calcClosureOfOneNode(arr, nodenum) {
    return calcClosureOfOneNode(createGraph(arr).edgemap, nodenum);
}
exports.calcClosureOfOneNode = ex_calcClosureOfOneNode;
//# sourceMappingURL=closure.js.map