
var clo = require('./closure/closureofdgraph.js');

var isStr = function (input) {
    return Object.prototype.toString.call(input) == '[object String]';
};

var isNum = function (input) {
    return Object.prototype.toString.call(input) == '[object Number]';
};

var isNonNegInt = function (input) {
    return isNum(input) && input >= 0 && Math.floor(input) === input;
};

var IdGen = function (start) {
    if (arguments.length > 0 && !isNonNegInt(start)) throw new Error('bad input of start: ' + start);
    this._id = start || 0;
};
IdGen.prototype.newId = function () {
    return this._id++;
};

var strictEqual = function (i1, i2) { return i1 === i2; };
//time cost: O(n^2), if copy array and sort first, it could be O(nlogn)
var arrayEquivalent = function (arr1, arr2, comparefn) {
    if (arr1.length !== arr2.length) return false;
    comparefn = comparefn || strictEqual;
    var len = arr1.length;
    var metarr = new Array(len);
    for (var i = 0; i < len; ++i) {
        var item1 = arr1[i];
        for (var j = 0; j < len; ++j) {
            if (metarr[j]) continue;
            var item2 = arr2[j];
            if (comparefn(item1, item2)) break;
        }
        if (j === len) return false; //not found
        metarr[j] = true;
    }
    return true;
};

var MapOfArr = function () {
    this._map = new Map();
};
MapOfArr.prototype.add = function (key, val) {
    var arr = this._map.get(key);
    if (arr == null) {
        arr = [];
        this._map.set(key, arr);
    }
    arr.push(val);
    return this;
};
MapOfArr.prototype.get = function (key) {
    return this._map.get(key);
};

var MapOfSet = function () {
    this._map = new Map();
};
MapOfSet.prototype.add = function (key, val) {
    var set = this._map.get(key);
    if (set == null) {
        set = new Set();
        this._map.set(key, set);
    }
    set.add(val);
    return this;
};
MapOfSet.prototype.get = function (key) {
    return this._map.get(key);
};

exports.isStr = isStr;
exports.IdGen = IdGen;
exports.isNonNegInt = isNonNegInt;
exports.calcClosure = clo.calcClosure;
exports.closureOfNodes = clo.closureOfNodes;
exports.arrayEquivalent = arrayEquivalent;
exports.MapOfArr = MapOfArr;
exports.MapOfSet = MapOfSet;
