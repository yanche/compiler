
var clo = require('./closure/closureofdgraph.js');

var isStr = function (input) {
    return Object.prototype.toString.call(input) == '[object String]';
};

var isNum = function (input) {
    return Object.prototype.toString.call(input) == '[object Number]';
};

var isNonNegInt = function (input) {
    return isNum(input) && input >= 0 && Math.floor(input) === input;
};

var IdGen = function (start) {
    if (arguments.length > 0 && !isNonNegInt(start)) throw new Error('bad input of start: ' + start);
    this._id = start || 0;
};
IdGen.prototype.newId = function () {
    return this._id++;
};

var strictEqual = function (i1, i2) { return i1 === i2; };
//time cost: O(n^2), if copy array and sort first, it could be O(nlogn)
var arrayEquivalent = function (arr1, arr2, comparefn) {
    if (arr1.length !== arr2.length) return false;
    comparefn = comparefn || strictEqual;
    var len = arr1.length;
    var metarr = new Array(len);
    for (var i = 0; i < len; ++i) {
        var item1 = arr1[i];
        for (var j = 0; j < len; ++j) {
            if (metarr[j]) continue;
            var item2 = arr2[j];
            if (comparefn(item1, item2)) break;
        }
        if (j === len) return false; //not found
        metarr[j] = true;
    }
    return true;
};

exports.isStr = isStr;
exports.IdGen = IdGen;
exports.isNonNegInt = isNonNegInt;
exports.calcClosure = clo.calcClosure;
exports.closureOfNodes = clo.closureOfNodes;
exports.arrayEquivalent = arrayEquivalent;
