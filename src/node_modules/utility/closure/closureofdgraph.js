
//closure of directed graph


var utility = require('utility');

var Closure = function () {
    this._set = new Set();      //contains nodenum
    this._owners = new Set();   //contains nodenum
};
Closure.prototype.addNode = function (nodenum) {
    this._set.add(nodenum);
    return this;
};
Closure.prototype.addOwnerNode = function (nodenum) {
    this._owners.add(nodenum);
    return this;
};
// Closure.prototype.removeOwnerNode = function (nodenum) {
//     this._owners.delete(nodenum);
//     return this;
// };
Closure.prototype.getOwnerNodes = function () {
    return [...this._owners];
};
Closure.prototype.getNodes = function () {
    return [...this._set];
};

//arr: [[0,1], [0,2], [2,1]] -> 3 directed edges: 0 to 1, 0 to 2, 2 to 1
var createGraph = function (arr) {
    if (!Array.isArray(arr)) throw new Error('input must be an array of edges');
    var map = new Map();
    var set = new Set();
    for (var i = 0; i < arr.length; ++i) {
        var edge = arr[i];
        if (!Array.isArray(edge) || edge.length != 2 || !utility.isNonNegInt(edge[0]) || !utility.isNonNegInt(edge[1])) throw new Error('invalid definition of edge: ' + edge);
        var snode = edge[0], tnode = edge[1];
        var edgeset = map.get(snode);
        if (edgeset == null) {
            edgeset = new Set();
            map.set(snode, edgeset);
        }
        edgeset.add(tnode);
        set.add(snode);
        set.add(tnode);
    }
    return { nodes: [...set], edges: map };
};

//graph: return from 'createGraph'
//return: map node->closure
var calcClosure = function (graph) {
    var colormap = new Map(), nlen = graph.nodes.length;
    var closuremap = new Map();
    if (nlen == 0) return closuremap;
    for (var i = 0; i < nlen; ++i) {
        colormap.set(graph.nodes[i], 0); //0:white, 1:grey: 2:black
    }
    var blackIdx = 0; //for index < blackIdx it's all in black color
    while (blackIdx < nlen) {
        calcClosureOfNode([], 0, graph.nodes[blackIdx], colormap, graph.edges, closuremap);
        while (blackIdx < nlen && colormap.get(graph.nodes[blackIdx]) == 2)++blackIdx;
    }
    return closuremap;
};

//state is in white color
var calcClosureOfNode = function (stack, stackTop, nodenum, colormap, edgesmap, closuremap) {
    stack[stackTop] = nodenum;
    addNodesToClosure(stack, 0, stackTop, [nodenum], closuremap);

    colormap.set(nodenum, 1); //grey: in stack, processing
    var edgeset = edgesmap.get(nodenum); //a set
    if (edgeset != null) {
        var edges = [...edgeset];
        for (var i = 0; i < edges.length; ++i) {
            var adjnodenum = edges[i];
            if (adjnodenum === nodenum) continue;
            var adjcolor = colormap.get(adjnodenum);
            var adjclosure = closuremap.get(adjnodenum);
            if (adjcolor === 2) {
                //adj state is black
                addNodesToClosure(stack, 0, stackTop, adjclosure.getNodes(), closuremap);
            }
            else if (adjcolor === 1) {
                //adj state is grey
                var adjidx = 0;
                while (adjidx <= stackTop && stack[adjidx] !== adjnodenum) adjidx++;
                if (adjidx > stackTop) throw new Error('impossible code path, cannot find grey adjstate in stack');
                var idx = adjidx + 1;
                while (idx <= stackTop) {
                    var owners = closuremap.get(stack[idx]).getOwnerNodes();
                    var processedowner = new Set();
                    for (var o = 0; o < owners.length; ++o) {
                        var ownernodenum = owners[o];
                        if (!processedowner.has(ownernodenum)) {
                            closuremap.set(ownernodenum, adjclosure);
                            adjclosure.addOwnerNode(ownernodenum);
                            processedowner.add(ownernodenum);
                        }
                    }
                    ++idx;
                }
            }
            else {
                calcClosureOfNode(stack, stackTop + 1, adjnodenum, colormap, edgesmap, closuremap);
            }
        }
    }
    colormap.set(nodenum, 2); //black: finished
};

var addNodesToClosure = function (nodearr, s, e, closurenodenums, closuremap) {
    var clen = closurenodenums.length;
    while (s <= e) {
        var snodenum = nodearr[s];
        var closure = closuremap.get(snodenum);
        if (closure == null) {
            closure = new Closure();
            closure.addOwnerNode(snodenum);
            closuremap.set(snodenum, closure);
        }
        for (var i = 0; i < clen; ++i)
            closure.addNode(closurenodenums[i]);
        ++s;
    }
};

//arr: [[0,1], [0,2], [2,1]] -> 3 directed edges: 0 to 1, 0 to 2, 2 to 1
//return: map node->closure
exports.calcClosure = function (arr) {
    return calcClosure(createGraph(arr));
};
//nodeIdArr: array of node id(non-neg integer)
//closuremap: result of calcClosure
exports.closureOfNodes = function (nodeIdArr, closuremap) {
    var ret = new Set();
    for (var j = 0; j < nodeIdArr.length; ++j) {
        var closurenodes = closuremap.get(nodeIdArr[j]).getNodes();
        for (var c = 0; c < closurenodes.length; ++c)
            ret.add(closurenodes[c]);
    }
    return [...ret];
};
