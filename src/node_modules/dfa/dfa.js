
var utility = require('utility');
var State = require('./state.js');

var DFA = function (trans, start, terminals) {
    if (!Array.isArray(trans) || trans.length === 0) throw new Error('bad input of transition array');
    if (!utility.isNonNegInt(start)) throw new Error('invalid input of start node number');
    if (!Array.isArray(terminals) || terminals.length === 0) throw new Error('invalid input of terminal nodes');
    var statenummap = new Map(), statect = 0;
    for (var t = 0; t < trans.length; ++t) {
        var tran = trans[t];
        var state = statenummap.get(tran.srcNode);
        if (state == null) {
            state = new State(tran.srcNode);
            statenummap.set(tran.srcNode, state);
            ++statect;
        }
        if (!statenummap.has(tran.tgtNode)) {
            statenummap.set(tran.tgtNode, new State(tran.tgtNode));
            ++statect;
        }
        state.addTransition(tran.symbol, tran.tgtNode);
    }
    if (!statenummap.has(start)) throw new Error('start state number not found in transition: ' + start);
    var terminalset = new Set();
    for (var i = 0; i < terminals.length; ++i) {
        var terminalnum = terminals[i];
        if (!statenummap.has(terminalnum)) throw new Error('invalid terminal num: ' + terminalnum);
        terminalset.add(terminalnum);
    }

    this._state_num_map = statenummap;
    this._start = start; //number
    this._terminals = terminalset; //SET of number
    this._trans = trans;
    this._statect = statect;
};
DFA.prototype.isTerminal = function (statenum) {
    return this._terminals.has(statenum);
};
DFA.prototype.accept = function (symbols) {
    var curstatenum = this._start, slen = symbols.length, i = 0;
    while (i < slen && curstatenum != null) {
        // 0 != null -> true
        curstatenum = this._state_num_map.get(curstatenum).getTransition(symbols[i++]);
    }
    return i == slen && curstatenum != null && this._terminals.has(curstatenum);
};
DFA.prototype.print = function () {
    console.log(this._statect + ' states in total');
    console.log('start state: ' + this._start);
    console.log('terminal states: ' + [...this._terminals].join(','));
    for (var i = 0; i < this._trans.length; ++i) this._trans[i].print();
};
DFA.prototype.equivalent = function (dfa) {
    if (this === dfa) return true; //self reference
    if (this._statect !== dfa._statect) return false; //different state count
    var t1 = [...this._terminals], t2 = [...dfa._terminals];
    if (t1.length !== t2.length) return false; //different terminal state count
    var statemap = new Map(), statemap2 = new Set(), queue = [this._start];
    statemap.set(this._start, dfa._start); //a map from state in 'this' to state in dfa
    statemap2.add(dfa._start);
    while (queue.length > 0) {
        var statenum1 = queue.pop(); //DFS
        var trans1 = this._state_num_map.get(statenum1).getAllTransitions();
        var state2 = dfa._state_num_map.get(statemap.get(statenum1));
        if (trans1.length != state2.getAllTransitions().length) return false;
        for (var t = 0; t < trans1.length; ++t) {
            var symbol = trans1[t][0], tgtstate = trans1[t][1];
            var tgtstate2 = state2.getTransition(symbol);
            if (tgtstate2 == null) return false; //dfa does not have the transition on this symbol
            var map1has = statemap.has(tgtstate), map2has = statemap2.has(tgtstate2);
            if (!map1has && !map2has) {
                statemap.set(tgtstate, tgtstate2);
                statemap2.add(tgtstate2); //set up equivalent states
                queue.push(tgtstate);
            }
            else if (map1has && map2has) {
                if (statemap.get(tgtstate) !== tgtstate2) return false; //different equivalent
            }
            else
                return false; //transition of this symbol to different equivalent state
        }
    }
    return true;
};

//trans: array of automata.Transition
//start: start node number
//terminals: terminal nodes number
exports.createDFA = function (trans, start, terminals) {
    return new DFA(trans, start, terminals);
};
