"use strict";
const prod = require('productions');
const utility = require('utility');
const nfa = require('NFA');
class Item {
    constructor(lhs, rhs, dot) {
        this.lhs = lhs;
        this.rhs = rhs;
        this.dot = dot;
        let arr = new Array(), i = 0, len = rhs.length;
        while (i <= len) {
            if (i === dot)
                arr[i] = '.';
            else if (i > dot)
                arr[i] = rhs[i - 1].getName();
            else
                arr[i] = rhs[i].getName();
            ++i;
        }
        this._id = lhs + ' -> ' + arr.join(' ');
    }
    print() {
        console.log(this._id);
        return this;
    }
}
class SLR1Parser {
    constructor(prodset) {
        let startnont = prodset.getStartNonTerminal(), queue = new Array(), itemnummap = new ItemNumMap();
        let nfatrans = new Array(), processednont = new Set(), startnfanums = new Array(), terminalnfanums = new Array();
        queue.push(startnont);
        while (queue.length > 0) {
            let lstr = queue.pop();
            processednont.add(lstr);
            for (let rsyms of prodset.getRHSArr(lstr)) {
                let nums = itemnummap.getOrCreateNums(lstr, rsyms), i = 0, len = rsyms.length;
                if (lstr === startnont) {
                    startnfanums.push(nums[0]);
                    terminalnfanums.push(nums[len]);
                }
                while (i < len) {
                    let rsym = rsyms[i];
                    let rname = rsym.getName();
                    nfatrans.push(new utility.automata.Transition(nums[i], nums[i + 1], rname));
                    if (!rsym.isTerminal()) {
                        let itemnum = nums[i];
                        for (let nrsyms of prodset.getRHSArr(rname)) {
                            let nnums = itemnummap.getOrCreateNums(rname, nrsyms);
                            nfatrans.push(new utility.automata.Transition(itemnum, nnums[0], ''));
                        }
                        if (!processednont.has(rname))
                            queue.push(rname);
                    }
                    ++i;
                }
            }
        }
        this._prodset = prodset;
        this._itemnummap = itemnummap;
        this._nfatrans = nfatrans;
        this._nfa = nfa.createNFA(nfatrans, startnfanums, terminalnfanums);
        let dfaret = this._nfa.toDFA();
        this._dfa = dfaret.dfa;
        this._dfanfastatemap = dfaret.statemap;
    }
    print() {
        console.log('DFA: ');
        this._dfa.print();
        for (let th of this._dfanfastatemap) {
            let dfanum = th[0], nfanums = th[1];
            console.log('DFA state ' + dfanum + ' contains items: ');
            for (let n of nfanums) {
                this._itemnummap.getItem(n).print();
            }
        }
        return this;
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SLR1Parser;
class ItemNumMap {
    constructor() {
        this._idgen = new utility.IdGen();
        this._itemmap = new Map();
        this._nummap = new Map();
    }
    getItem(num) { return this._nummap.get(num); }
    getOrCreateNums(lhs, rhs) {
        let pid = prod.Production.id(lhs, rhs), len = rhs.length;
        if (this._itemmap.has(pid))
            return this._itemmap.get(pid);
        let arr = new Array(len + 1);
        for (let i = 0; i <= len; ++i) {
            let num = this._idgen.next();
            arr[i] = num;
            this._nummap.set(num, new Item(lhs, rhs, i));
        }
        this._itemmap.set(pid, arr);
        return arr;
    }
}
//# sourceMappingURL=parser.js.map