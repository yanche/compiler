"use strict";
const prod = require('productions');
const utility = require('utility');
const nfa = require('NFA');
const _ = require('lodash');
class Item {
    constructor(lhs, rhs, dot) {
        this.lhs = lhs;
        this.rhs = rhs;
        this.dot = dot;
        let arr = new Array(), i = 0, len = rhs.length;
        while (i <= len) {
            if (i === dot)
                arr[i] = '.';
            else if (i > dot)
                arr[i] = rhs[i - 1].getName();
            else
                arr[i] = rhs[i].getName();
            ++i;
        }
        this._id = lhs + ' -> ' + arr.join(' ');
    }
    print() {
        console.log(this._id);
        return this;
    }
}
class Action {
}
class ShiftAction extends Action {
    constructor(toStateNum) {
        super();
        this.toStateNum = toStateNum;
    }
}
class ReduceAction extends Action {
    constructor(nont, rhslen) {
        super();
        this.nont = nont;
    }
}
class AcceptAction extends Action {
}
class SLR1ParseTable {
    constructor() {
        this._ptable = new Map();
        this._ambcells = new Set();
    }
    addAcceptAction(dfastatenum, symnum) {
        return this.addAction(dfastatenum, symnum, new AcceptAction());
    }
    addShiftAction(dfastatenum, tranmap) {
        for (let tran of tranmap) {
            this.addAction(dfastatenum, tran[0], new ShiftAction(tran[1]));
        }
        return this;
    }
    addReduceAction(dfastatenum, follows, lnum, reducecount) {
        for (let f of follows) {
            this.addAction(dfastatenum, f, new ReduceAction(lnum, reducecount));
        }
        return this;
    }
    addAction(dfastatenum, symnum, action) {
        let row = this.initRow(dfastatenum);
        let acts = row.get(symnum);
        if (acts == null)
            row.set(symnum, [action]);
        else {
            acts.push(action);
            this.markAmbiguousCell(dfastatenum);
        }
        return this;
    }
    markAmbiguousCell(dfastatenum) {
        this._ambcells.add(dfastatenum);
        return this;
    }
    initRow(dfastatenum) {
        let ret = this._ptable.get(dfastatenum);
        if (ret == null) {
            ret = new Map();
            this._ptable.set(dfastatenum, ret);
        }
        return ret;
    }
}
class SLR1Parser {
    constructor(prodset) {
        let prodsize = prodset.getProdSize(), startnontnum = prodset.getStartNonTerminal(), lastitemid;
        let itemnummap = new Array(prodsize), itemidgen = new utility.IdGen(), numitemmap = new Map();
        let nfatrans = new Array(), startitems = new Array(), parsetable = new SLR1ParseTable(), followsets = prodset.followSet();
        for (let prodid = 0; prodid < prodsize; ++prodid) {
            let prod = prodset.getProdRef(prodid);
            let start = prod.lnum === startnontnum;
            let arr = new Array(prod.rnums.length + 1);
            for (let i = 0; i <= prod.rnums.length; ++i) {
                let itemid = itemidgen.next();
                arr[i] = itemid;
                numitemmap.set(itemid, { prodid: prodid, dot: i, prod: prod });
                lastitemid = itemid;
                if (start && i === 0)
                    startitems.push(itemid);
            }
            itemnummap[prodid] = arr;
        }
        for (let prodid = 0; prodid < prodsize; ++prodid) {
            let prod = prodset.getProdRef(prodid), itemarr = itemnummap[prodid];
            for (let i = 0; i < prod.rnums.length; ++i) {
                let rnum = prod.rnums[i], curitem = itemarr[i];
                let rsymstr = prodset.getSymInStr(rnum);
                nfatrans.push(new utility.automata.Transition(curitem, itemarr[i + 1], rsymstr));
                if (!prodset.isSymNumTerminal(rnum)) {
                    for (let prodid2 of prodset.getProds(rnum)) {
                        nfatrans.push(new utility.automata.Transition(curitem, itemnummap[prodid2][0], ''));
                    }
                }
            }
        }
        this._prodset = prodset;
        this._itemnummap = itemnummap;
        this._numitemmap = numitemmap;
        this._nfatrans = nfatrans;
        this._nfa = nfa.createNFA(nfatrans, startitems, _.range(lastitemid + 1));
        let dfaret = this._nfa.toDFA();
        this._dfa = dfaret.dfa;
        this._dfanfastatemap = dfaret.statemap;
        this._parsetable = parsetable;
        parsetable.addAcceptAction(this._dfa.getStartState(), startnontnum);
        for (let dstate of dfaret.statemap) {
            let dfanum = dstate[0], nfanums = dstate[1];
            parsetable.addShiftAction(dfanum, [...this._dfa.getTransitionMap(dfanum)].map(x => [prodset.getSymNum(x[0]), x[1]]));
            for (let n of nfanums) {
                let item = numitemmap.get(n);
                if (item.dot === item.prod.rnums.length) {
                    parsetable.addReduceAction(dfanum, followsets.get(item.prod.lnum), item.prod.lnum, item.dot);
                }
            }
        }
    }
    print() {
        console.log('DFA: ');
        this._dfa.print();
        for (let th of this._dfanfastatemap) {
            let dfanum = th[0], nfanums = th[1];
            console.log('DFA state ' + dfanum + ' contains items: ');
            for (let n of nfanums) {
                this._numitemmap.get(n).prod.prod.print();
            }
        }
        return this;
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SLR1Parser;
class ItemNumMap {
    constructor() {
        this._idgen = new utility.IdGen();
        this._itemmap = new Map();
        this._nummap = new Map();
    }
    getItem(num) { return this._nummap.get(num); }
    getOrCreateNums(lhs, rhs) {
        let pid = prod.Production.id(lhs, rhs), len = rhs.length;
        if (this._itemmap.has(pid))
            return this._itemmap.get(pid);
        let arr = new Array(len + 1);
        for (let i = 0; i <= len; ++i) {
            let num = this._idgen.next();
            arr[i] = num;
            this._nummap.set(num, new Item(lhs, rhs, i));
        }
        this._itemmap.set(pid, arr);
        return arr;
    }
}
//# sourceMappingURL=parser.js.map