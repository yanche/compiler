
import * as prod from 'productions';
import * as utility from 'utility';
import * as dfa from 'DFA';
import * as nfa from 'NFA';
import * as _ from 'lodash';

class Item {
    private _id: string;
    constructor(public lhs: string, public rhs: Array<prod.Symbol>, public dot: number) {
        let arr = new Array<string>(), i = 0, len = rhs.length;
        while (i <= len) {
            if (i === dot) arr[i] = '.';
            else if (i > dot) arr[i] = rhs[i - 1].getName();
            else arr[i] = rhs[i].getName();
            ++i;
        }
        this._id = lhs + ' -> ' + arr.join(' ');
    }
    print(): this {
        console.log(this._id);
        return this;
    }
}

abstract class Action { }
class ShiftAction extends Action {
    constructor(public toStateNum: number) { super(); }
}
class ReduceAction extends Action {
    constructor(public nont: number, rhslen: number) { super(); }
}
class AcceptAction extends Action { }

class SLR1ParseTable {
    private _ptable: Map<number, Map<number, Array<Action>>>;
    private _ambcells: Set<number>;

    constructor() {
        this._ptable = new Map<number, Map<number, Array<Action>>>();
        this._ambcells = new Set<number>();
    }
    addAcceptAction(dfastatenum: number, symnum: number): this {
        return this.addAction(dfastatenum, symnum, new AcceptAction());
    }
    addShiftAction(dfastatenum: number, tranmap: Array<Array<number>>): this {
        for (let tran of tranmap) {
            //tran[0]: sym number, tran[1]: dfa state number
            this.addAction(dfastatenum, tran[0], new ShiftAction(tran[1]));
        }
        return this;
    }
    addReduceAction(dfastatenum: number, follows: Iterable<number>, lnum: number, reducecount: number) {
        for (let f of follows) {
            this.addAction(dfastatenum, f, new ReduceAction(lnum, reducecount));
        }
        return this;
    }
    private addAction(dfastatenum: number, symnum: number, action: Action): this {
        let row = this.initRow(dfastatenum);
        let acts = row.get(symnum);
        if (acts == null) row.set(symnum, [action]);
        else {
            acts.push(action);
            this.markAmbiguousCell(dfastatenum);
        }
        return this;
    }
    private markAmbiguousCell(dfastatenum: number): this {
        this._ambcells.add(dfastatenum);
        return this;
    }
    private initRow(dfastatenum: number): Map<number, Array<Action>> {
        let ret = this._ptable.get(dfastatenum);
        if (ret == null) {
            ret = new Map<number, Array<Action>>()
            this._ptable.set(dfastatenum, ret);
        }
        return ret;
    }
}

export default class SLR1Parser {
    private _prodset: prod.ProdSet;
    private _itemnummap: Array<Array<number>>;
    private _numitemmap: Map<number, { prodid: number, dot: number, prod: prod.ProductionRef }>;
    private _nfatrans: Array<utility.automata.Transition>;
    private _nfa: nfa.NFA;
    private _dfa: dfa.DFA;
    private _dfanfastatemap: Map<number, Set<number>>;
    private _parsetable: SLR1ParseTable;

    constructor(prodset: prod.ProdSet) {
        let prodsize = prodset.getProdSize(), startnontnum = prodset.getStartNonTerminal(), lastitemid: number;
        let itemnummap = new Array<Array<number>>(prodsize), itemidgen = new utility.IdGen(), numitemmap = new Map<number, { prodid: number, dot: number, prod: prod.ProductionRef }>();
        let nfatrans = new Array<utility.automata.Transition>(), startitems = new Array<number>(), parsetable = new SLR1ParseTable(), followsets = prodset.followSet();

        //prodid from 0 -> prodsize - 1
        //loop 1, build the item num mapping
        //number of item, is the number of NFA
        for (let prodid = 0; prodid < prodsize; ++prodid) {
            let prod = prodset.getProdRef(prodid);
            let start = prod.lnum === startnontnum;
            let arr = new Array<number>(prod.rnums.length + 1);
            for (let i = 0; i <= prod.rnums.length; ++i) {
                let itemid = itemidgen.next();
                arr[i] = itemid;
                numitemmap.set(itemid, { prodid: prodid, dot: i, prod: prod });
                lastitemid = itemid;
                if (start && i === 0) startitems.push(itemid);
            }
            itemnummap[prodid] = arr;
        }

        for (let prodid = 0; prodid < prodsize; ++prodid) {
            let prod = prodset.getProdRef(prodid), itemarr = itemnummap[prodid];
            for (let i = 0; i < prod.rnums.length; ++i) {
                let rnum = prod.rnums[i], curitem = itemarr[i];
                let rsymstr = prodset.getSymInStr(rnum);
                nfatrans.push(new utility.automata.Transition(curitem, itemarr[i + 1], rsymstr));
                if (!prodset.isSymNumTerminal(rnum)) {
                    for (let prodid2 of prodset.getProds(rnum)) {
                        nfatrans.push(new utility.automata.Transition(curitem, itemnummap[prodid2][0], ''));
                    }
                }
            }
        }

        this._prodset = prodset;
        this._itemnummap = itemnummap;
        this._numitemmap = numitemmap;
        this._nfatrans = nfatrans;
        //todo: terminalnfanums
        this._nfa = nfa.createNFA(nfatrans, startitems, _.range(lastitemid + 1));
        let dfaret = this._nfa.toDFA();
        this._dfa = dfaret.dfa;
        this._dfanfastatemap = dfaret.statemap;
        this._parsetable = parsetable;

        //construct parsing table SLR(1)
        parsetable.addAcceptAction(this._dfa.getStartState(), startnontnum);
        for (let dstate of dfaret.statemap) {
            let dfanum = dstate[0], nfanums = dstate[1];
            parsetable.addShiftAction(dfanum, [...this._dfa.getTransitionMap(dfanum)].map(x => [prodset.getSymNum(x[0]), x[1]]));
            for (let n of nfanums) {
                //state number of NFA is the number of item
                let item = numitemmap.get(n);
                if (item.dot === item.prod.rnums.length) {
                    parsetable.addReduceAction(dfanum, followsets.get(item.prod.lnum), item.prod.lnum, item.dot);
                }
            }
        }
    }
    print(): this {
        console.log('DFA: ');
        this._dfa.print();
        for (let th of this._dfanfastatemap) {
            let dfanum = th[0], nfanums = th[1];
            console.log('DFA state ' + dfanum + ' contains items: ');
            for (let n of nfanums) {
                this._numitemmap.get(n).prod.prod.print();
            }
        }
        return this;
    }
}

class ItemNumMap {
    private _itemmap: Map<string, Array<number>>;
    private _nummap: Map<number, Item>;
    private _idgen: utility.IdGen;

    constructor() {
        this._idgen = new utility.IdGen();
        this._itemmap = new Map<string, Array<number>>();
        this._nummap = new Map<number, Item>();
    }
    getItem(num: number): Item { return this._nummap.get(num); }
    getOrCreateNums(lhs: string, rhs: Array<prod.Symbol>): Array<number> {
        let pid = prod.Production.id(lhs, rhs), len = rhs.length;
        if (this._itemmap.has(pid)) return this._itemmap.get(pid);
        let arr = new Array<number>(len + 1);
        for (let i = 0; i <= len; ++i) {
            let num = this._idgen.next();
            arr[i] = num;
            this._nummap.set(num, new Item(lhs, rhs, i));
        }
        this._itemmap.set(pid, arr);
        return arr;
    }
}
