
import * as prod from 'productions';
import * as utility from 'utility';
import * as dfa from 'DFA';
import * as nfa from 'NFA';
import * as _ from 'lodash';
import * as p from 'parse';
import * as putil from './util';


function itemInStr(bitem: putil.LR0Item, symnum: number, prodset: prod.ProdSet): string {
    let rnums = bitem.prod.rnums;
    let arr = new Array<string>(), i = 0, len = rnums.length;
    while (i <= len) {
        if (i === bitem.dot) arr[i] = '.';
        else if (i > bitem.dot) arr[i] = prodset.getSymInStr(rnums[i - 1]);
        else arr[i] = prodset.getSymInStr(rnums[i]);
        ++i;
    }
    return prodset.getSymInStr(bitem.prod.lnum) + ' -> ' + arr.join(' ') + ' , ' + prodset.getSymInStr(symnum);
}


export default class LR1Parser extends p.Parser {
    private _numbitemmap: Array<putil.LR0Item>;
    private _nfa: nfa.NFA;
    private _dfa: dfa.DFA;
    private _dfanfastatemap: Map<number, Set<number>>;
    private _allitems: Set<number>;
    private _parsetable: putil.LRParseTable;
    private _ctlookaheadsym: number;

    constructor(prodset: prod.ProdSet) {
        super(prodset);
        let processeditems = new Set<number>(), terminals = prodset.getTerminals(), prodsize = prodset.getProdSize(), startnontnum = prodset.getStartNonTerminal(), nfatrans = new Array<utility.automata.Transition>();
        let bitemidgen = new utility.IdGen(0), lastitemid = 0, numbitemmap = new Array<putil.LR0Item>(), startbitems = new Array<number>(), bitemnummap = new Array<Array<number>>(prodsize), ctlookaheadsym = terminals.length + 1; //includes all terminal symbols and '$'
        let firstsets = prodset.firstSet(), nullableterminals = prodset.nullableNonTerminals();

        //prodid from 0 -> prodsize - 1
        //loop 1, build the bitem num mapping (bitem means the item of LR(0))
        for (let prodid = 0; prodid < prodsize; ++prodid) {
            let prod = prodset.getProdRef(prodid);
            let start = prod.lnum === startnontnum;
            let arr = new Array<number>(prod.rnums.length + 1);
            for (let i = 0; i <= prod.rnums.length; ++i) {
                let itemid = bitemidgen.next();
                arr[i] = itemid;
                numbitemmap.push({ prodid: prodid, dot: i, prod: prod });
                lastitemid = itemid;
                if (start && i === 0) startbitems.push(itemid);
            }
            bitemnummap[prodid] = arr;
        }

        let itemqueue = startbitems.map(x => { let itemnum = x * ctlookaheadsym; processeditems.add(itemnum); return itemnum; }); //start items
        let startitems = [].concat(itemqueue);
        while (itemqueue.length > 0) {
            let itemnum = itemqueue.pop();
            let bitemnum = Math.floor(itemnum / ctlookaheadsym), symnum = itemnum % ctlookaheadsym; //symnum: the lookahead symbol of item of LR(1)
            let bitem = numbitemmap[bitemnum];
            let rnums = bitem.prod.rnums;
            if (bitem.dot < rnums.length) {
                let dotsym = rnums[bitem.dot];
                addNFATran(new utility.automata.Transition(itemnum, bitemnummap[bitem.prodid][bitem.dot + 1] * ctlookaheadsym + symnum, prodset.getSymInStr(dotsym)), nfatrans, itemqueue, processeditems);
                if (!prodset.isSymNumTerminal(dotsym)) {
                    let firsts = new Set<number>(), dot = bitem.dot + 1, gonull = true;
                    while (dot < rnums.length && gonull) {
                        for (let f of firstsets[rnums[dot]]) firsts.add(f);
                        gonull = nullableterminals.has(rnums[dot]);
                        ++dot;
                    }
                    if (dot === rnums.length && gonull) firsts.add(symnum);
                    for (let prodid of prodset.getProds(dotsym)) {
                        let bitemid = bitemnummap[prodid][0];
                        for (let f of firsts)
                            addNFATran(new utility.automata.Transition(itemnum, bitemid * ctlookaheadsym + f, ''), nfatrans, itemqueue, processeditems);
                    }
                }
            }
        }

        this._allitems = processeditems;
        this._nfa = nfa.createNFA(nfatrans, startitems, processeditems);
        let dfaret = this._nfa.toDFA();
        this._dfa = dfaret.dfa;
        this._dfanfastatemap = dfaret.statemap;
        this._numbitemmap = numbitemmap;
        this._ctlookaheadsym = ctlookaheadsym;

        let parsetable = new putil.LRParseTable(prodset);
        //construct parsing table SLR(1)
        parsetable.addAcceptAction(this._dfa.getStartState(), startnontnum);
        for (let dstate of dfaret.statemap) {
            let dfanum = dstate[0], nfanums = dstate[1];
            parsetable.addShiftAction(dfanum, [...this._dfa.getTransitionMap(dfanum)].map(x => [prodset.getSymNum(x[0]), x[1]]));
            for (let n of nfanums) {
                //state number of NFA is the number of item
                let bitem = numbitemmap[Math.floor(n / ctlookaheadsym)];
                if (bitem.dot === bitem.prod.rnums.length) {
                    //reduce item
                    parsetable.addReduceAction(dfanum, n % ctlookaheadsym, bitem.prod.lnum, bitem.dot);
                }
            }
        }

        this._parsetable = parsetable;
    }
    print(): this {
        console.log('DFA: ');
        this._dfa.print();
        for (let th of this._dfanfastatemap) {
            let dfanum = th[0], nfanums = th[1];
            console.log('DFA state ' + dfanum + ' contains items: ');
            for (let n of nfanums) {
                console.log(itemInStr(this._numbitemmap[Math.floor(n / this._ctlookaheadsym)], n % this._ctlookaheadsym, this._prodset));
            }
        }
        return this;
    }
    parse(tokens: Array<p.Token>): p.ParseReturn {
        return this._parsetable.parse(tokens, this._dfa.getStartState());
    }
}

function addNFATran(tran: utility.automata.Transition, trans: Array<utility.automata.Transition>, itemqueue: Array<number>, processeditems: Set<number>) {
    trans.push(tran);
    if (!processeditems.has(tran.tgt)) {
        processeditems.add(tran.tgt);
        itemqueue.push(tran.tgt);
    }
}
