
import * as prod from 'productions';
import * as utility from 'utility';
import * as dfa from 'DFA';
import * as nfa from 'NFA';
import * as _ from 'lodash';
import * as p from 'parse';
import * as putil from './util';


function itemInStr(item: putil.LR0Item, prodset: prod.ProdSet): string {
    let rnums = item.prod.rnums;
    let arr = new Array<string>(), i = 0, len = rnums.length;
    while (i <= len) {
        if (i === item.dot) arr[i] = '.';
        else if (i > item.dot) arr[i] = prodset.getSymInStr(rnums[i - 1]);
        else arr[i] = prodset.getSymInStr(rnums[i]);
        ++i;
    }
    return prodset.getSymInStr(item.prod.lnum) + ' -> ' + arr.join(' ');
}


export default class SLR1Parser extends p.Parser {
    private _itemnummap: Array<Array<number>>;
    private _numitemmap: Array<putil.LR0Item>;
    private _nfatrans: Array<utility.automata.Transition>;
    private _nfa: nfa.NFA;
    private _dfa: dfa.DFA;
    private _dfanfastatemap: Map<number, Set<number>>;
    private _parsetable: putil.LRParseTable;
    private _isLR0: boolean;

    constructor(prodset: prod.ProdSet) {
        super(prodset);
        let prodsize = prodset.getProdSize(), startnontnum = prodset.getStartNonTerminal(), lastitemid: number;
        let itemnummap = new Array<Array<number>>(prodsize), itemidgen = new utility.IdGen(0), numitemmap = new Array<putil.LR0Item>();
        let nfatrans = new Array<utility.automata.Transition>(), startitems = new Array<number>(), parsetable = new putil.LRParseTable(prodset), followsets = prodset.followSet();

        //prodid from 0 -> prodsize - 1
        //loop 1, build the item num mapping
        //number of item, is the number of NFA
        for (let prodid = 0; prodid < prodsize; ++prodid) {
            let prod = prodset.getProdRef(prodid);
            let start = prod.lnum === startnontnum;
            let arr = new Array<number>(prod.rnums.length + 1);
            for (let i = 0; i <= prod.rnums.length; ++i) {
                let itemid = itemidgen.next();
                arr[i] = itemid;
                numitemmap.push({ prodid: prodid, dot: i, prod: prod });
                lastitemid = itemid;
                if (start && i === 0) startitems.push(itemid);
            }
            itemnummap[prodid] = arr;
        }

        for (let prodid = 0; prodid < prodsize; ++prodid) {
            let prod = prodset.getProdRef(prodid), itemarr = itemnummap[prodid];
            for (let i = 0; i < prod.rnums.length; ++i) {
                let rnum = prod.rnums[i], curitem = itemarr[i];
                let rsymstr = prodset.getSymInStr(rnum);
                nfatrans.push(new utility.automata.Transition(curitem, itemarr[i + 1], rsymstr));
                if (!prodset.isSymNumTerminal(rnum)) {
                    for (let prodid2 of prodset.getProds(rnum)) {
                        nfatrans.push(new utility.automata.Transition(curitem, itemnummap[prodid2][0], ''));
                    }
                }
            }
        }

        this._itemnummap = itemnummap;
        this._numitemmap = numitemmap;
        this._nfatrans = nfatrans;
        //todo: terminalnfanums
        this._nfa = nfa.createNFA(nfatrans, startitems, _.range(lastitemid + 1));
        let dfaret = this._nfa.toDFA();
        this._dfa = dfaret.dfa;
        this._dfanfastatemap = dfaret.statemap;
        this._parsetable = parsetable;

        let isLR0 = true;
        //construct parsing table SLR(1)
        parsetable.addAcceptAction(this._dfa.getStartState(), startnontnum);
        for (let dstate of dfaret.statemap) {
            let dfanum = dstate[0], nfanums = dstate[1];
            parsetable.addShiftAction(dfanum, [...this._dfa.getTransitionMap(dfanum)].map(x => [prodset.getSymNum(x[0]), x[1]]));
            let hasreducemove = false;
            for (let n of nfanums) {
                //state number of NFA is the number of item
                let item = numitemmap[n];
                if (item.dot === item.prod.rnums.length) {
                    hasreducemove = true;
                    parsetable.addReduceActions(dfanum, followsets[item.prod.lnum], item.prod.lnum, item.dot);
                }
            }
            if (isLR0 && hasreducemove && nfanums.size > 1)
                isLR0 = false;
        }

        this._isLR0 = isLR0;
    }
    isLR0Grammar(): boolean { return this._isLR0; }
    print(): this {
        console.log('DFA: ');
        this._dfa.print();
        for (let th of this._dfanfastatemap) {
            let dfanum = th[0], nfanums = th[1];
            console.log('DFA state ' + dfanum + ' contains items: ');
            for (let n of nfanums) {
                console.log(itemInStr(this._numitemmap[n], this._prodset));
            }
        }
        return this;
    }
    parse(tokens: Array<p.Token>): p.ParseReturn {
        return this._parsetable.parse(tokens, this._dfa.getStartState());
    }
}
