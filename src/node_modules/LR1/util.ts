
import * as prod from 'productions';
import * as p from 'parse';

//FOR LR parse-table
abstract class Action { }
class ShiftAction extends Action {
    constructor(public toStateNum: number) { super(); }
}
class ReduceAction extends Action {
    constructor(public nont: number, public rhslen: number) { super(); }
}
class AcceptAction extends Action { }

export interface LR0Item {
    prodid: number,
    dot: number,
    prod: prod.ProductionRef
}

//LR parse table, LR(0), LR(1), SLR(1)
export class LRParseTable {
    private _ptable: Map<number, Map<number, Array<Action>>>;
    private _ambcells: Set<number>;
    private _prodset: prod.ProdSet;

    constructor(prodset: prod.ProdSet) {
        this._ptable = new Map<number, Map<number, Array<Action>>>();
        this._ambcells = new Set<number>();
        this._prodset = prodset;
    }
    addAcceptAction(dfastatenum: number, symnum: number): this {
        return this.addAction(dfastatenum, symnum, new AcceptAction());
    }
    addShiftAction(dfastatenum: number, tranmap: Array<Array<number>>): this {
        for (let tran of tranmap) {
            //tran[0]: sym number, tran[1]: dfa state number
            this.addAction(dfastatenum, tran[0], new ShiftAction(tran[1]));
        }
        return this;
    }
    addReduceActions(dfastatenum: number, follows: Iterable<number>, lnum: number, reducecount: number) {
        for (let f of follows) {
            this.addReduceAction(dfastatenum, f, lnum, reducecount);
        }
        return this;
    }
    addReduceAction(dfastatenum: number, symnum: number, lnum: number, reducecount: number) {
        this.addAction(dfastatenum, symnum, new ReduceAction(lnum, reducecount));
        return this;
    }
    private addAction(dfastatenum: number, symnum: number, action: Action): this {
        let row = this.initRow(dfastatenum);
        let acts = row.get(symnum);
        if (acts == null) row.set(symnum, [action]);
        else {
            acts.push(action);
            this.markAmbiguousCell(dfastatenum);
        }
        return this;
    }
    private markAmbiguousCell(dfastatenum: number): this {
        this._ambcells.add(dfastatenum);
        return this;
    }
    private initRow(dfastatenum: number): Map<number, Array<Action>> {
        let ret = this._ptable.get(dfastatenum);
        if (ret == null) {
            ret = new Map<number, Array<Action>>()
            this._ptable.set(dfastatenum, ret);
        }
        return ret;
    }
    parse(tokens: Array<p.Token>, startstate: number): p.ParseReturn {
        if (this._ambcells.size > 0) return new p.ParseReturn(false, null, 'the grammar is not a valid SLR(1)', 0);
        let stack = new Array<{ tnode: p.ParseTreeNode, state: number }>(), i = 0, len = tokens.length;
        stack.push({ tnode: null, state: startstate });
        let stacktop = 0;
        while (i <= len) {
            let token: p.Token = ((i === len) ? { rawstr: '', symnum: 0 } : tokens[i]), stackitem = stack[stacktop];
            let acts = this._ptable.get(stackitem.state).get(token.symnum);
            if (acts == null || acts.length === 0) return new p.ParseReturn(false, null, 'input not acceptable', 1);
            let act = acts[0];
            if (act instanceof ShiftAction) {
                stack[++stacktop] = { tnode: new p.ParseTreeTermNode(token.symnum, this._prodset, token), state: act.toStateNum };
                ++i;
            }
            else if (act instanceof ReduceAction) {
                let newstacktop = stacktop - act.rhslen;
                let midnode = new p.ParseTreeMidNode(act.nont, this._prodset, stack.slice(newstacktop + 1, stacktop + 1).map(x => x.tnode));
                let newact = this._ptable.get(stack[newstacktop].state).get(act.nont)[0];
                if (newact instanceof ShiftAction) {
                    stack[++newstacktop] = { tnode: midnode, state: newact.toStateNum };
                    stacktop = newstacktop;
                }
                else if (newact instanceof AcceptAction) {
                    if (i === len) return new p.ParseReturn(true, midnode);
                    else return new p.ParseReturn(false, null, 'input not acceptable, reach to the end of parsing before consume all tokens', 2);
                }
                else throw new Error('impossible code path'); //reserved code path, should be no possible here
            }
            else throw new Error('impossible code path, 2'); //reserved code path, should be no possible here
        }
        throw new Error('impossible code path, 3'); //reserved code path, should be no possible here
    }
}
