
import * as utility from 'utility';
import * as t from './tac';
import * as r from './regallocate';
import * as m from './mipscode';
//import * as tc from './typecheck';
import * as util from './util';

//FOR INTERMEDIATE CODE GENERATION AND OPTIMIZATION

function inferTopTmpRegValues(from: Array<CodeLineRegInfoInferences>, to: CodeLineRegInfoInferences): boolean {
    if (from.length === 0) return false;
    let flen = to.top.length, changed = false;
    for (let i = 0; i < flen; ++i) {
        let fromslice = from.map(r => r.bottom[i]);
        if (to.top[i].mergeFrom(fromslice)) changed = true;
    }
    return changed;
}

function inferBottomTmpRegValues(tac: t.TAC, regvinfer: CodeLineRegInfoInferences): boolean {
    let o = tac.inferTmpRegValue(regvinfer.top), changed = false, rlen = regvinfer.bottom.length;
    for (let i = 0; i < rlen; ++i) {
        if (regvinfer.bottom[i].mergeFrom([(o == null || o.regnum !== i) ? regvinfer.top[i] : o.reginfo])) changed = true;
    }
    return changed;
}

function valueInference(codelines: Array<CodeLine>, regvinfer: Array<CodeLineRegInfoInferences>) {
    //console.log('folding ' + this._fnsig);
    let clen = codelines.length;
    for (let i = 0; i < clen; ++i)codelines[i].linenum = i;
    let stack = [0], stacktop = 1, first = true;
    while (stacktop > 0) {
        let codeseq = stack[--stacktop];
        //console.log('taking ' + this._codelines[codeseq].toString());
        let cl = codelines[codeseq], clregvinfer = regvinfer[codeseq];
        let from = cl.branchInCL();
        if (codeseq > 0) from = from.concat(codelines[codeseq - 1]);
        if (first || inferTopTmpRegValues(from.map(n => regvinfer[n.linenum]), clregvinfer)) {
            first = false;
            if (inferBottomTmpRegValues(cl.tac, clregvinfer)) {
                let extrato = cl.branchToCL();
                let tocodelines = extrato == null ? [] : [extrato];
                if (codeseq !== clen - 1)
                    tocodelines.push(codelines[codeseq + 1]);
                for (let cl of tocodelines) {
                    let j = 0, linenum = cl.linenum;
                    for (; j < stacktop; ++j) {
                        if (stack[j] === linenum) break;
                    }
                    //to be processed
                    if (j === stacktop) stack[stacktop++] = linenum;
                }
            }
        }
    }
}

function finalizeLabelRef(codelines: Array<CodeLine>) {
    for (let cl of codelines)
        if (cl.label != null)
            cl.label.upstreams = new Array<CodeLine>();
    for (let cl of codelines) {
        let tac = cl.tac;
        if (tac instanceof t.TAC_branch)
            tac.label.upstreams.push(cl);
    }
    for (let cl of codelines) {
        if (cl.label != null) {
            if (cl.label.upstreams.length > 0)
                cl.label.owner = cl;
            else
                cl.label = null;
        }
    }
    return this;
}

export function generateIntermediateCode(classlookup: util.ClassLookup, fnlookup: util.FunctionLookup): IntermediateCode {
    let code = new IntermediateCode();
    for (let classname of classlookup.getAllClasses().concat(null)) {
        let classdef = classlookup.getClass(classname);
        for (let fndef of fnlookup.findMethods(classname)) {
            let codelines = new CodeLineCollector();
            fndef.astnode.genIntermediateCode(codelines);
            finalizeLabelRef(codelines._arr);
            let cllen = codelines._arr.length;
            //each code-line would have one reg-info-inference record (one for input one for output)
            let clvalueinfer = new Array<CodeLineRegInfoInferences>(cllen);
            for (let i = 0; i < cllen; ++i)
                clvalueinfer[i] = new CodeLineRegInfoInferences(fndef.astnode.tmpRegAssigned);
            console.log('parameter tmp register for: ' + fndef.name);
            console.log(fndef.astnode.argTmpRegIdList);
            for (let i of fndef.astnode.argTmpRegIdList)
                clvalueinfer[0].top[i].type = TmpRegValueInference.TYPE_ANY;
            valueInference(codelines._arr, clvalueinfer);
            //todo: fold
        }
    }
    return code;
}

class CodeLineRegInfoInferences {
    top: Array<TmpRegValueInference>;
    bottom: Array<TmpRegValueInference>;
    constructor(regcount: number) {
        this.top = new Array<TmpRegValueInference>();
        this.bottom = new Array<TmpRegValueInference>();
    }
}

export class CodeLineCollector {
    _arr: Array<CodeLine>;
    add(tac: t.TAC, label?: util.CodeLabel): this {
        this._arr.push(new CodeLine(tac, label));
        return this;
    }
    constructor() {
        this._arr = new Array<CodeLine>();
    }
}

export class IntermediateCode {
    private _codepieces: Array<CodePiece>;
    //private _gdatapieces: Array<GDATA>;
    private _labelidgen: utility.IdGen;

    // toMIPS(classlookup: util.ClassLookup): m.MIPSAssembly {
    //     let ret = new m.MIPSAssembly();
    //     //pre-defined function, vtable initializer
    //     ret.addCode(new m.MIPS_nop(), m.MIPS_VTABLE_INIT_LABEL);
    //     for (let cname of classlookup.getAllClasses()) {
    //         let cdef = classlookup.getClass(cname);
    //         let vtable = cdef.getVTable();
    //         if (vtable.length > 0) {
    //             let vtablelabel = gdataLabel(cdef.getVTableLabel());
    //             ret.addGData(new m.MIPSGData_word(vtable.length), vtablelabel);
    //             ret.addGData(new m.MIPSGData_emptyline());
    //             for (let i = 0; i < vtable.length; ++i) {
    //                 ret.addCode(new m.MIPS_la(m.regs.v0, fnLabel(vtable[i].signiture)));
    //                 ret.addCode(new m.MIPS_la(m.regs.v1, vtablelabel));
    //                 ret.addCode(new m.MIPS_sw(m.regs.v0, new m.MIPSAddr_reg(4 * i, m.regs.v1)));
    //             }
    //         }
    //     }
    //     ret.addCode(new m.MIPS_jr(m.regs.ra));
    //     ret.addCode(new m.MIPS_emptyline());
    //     //new line global data (asciiz)
    //     ret.addGData(new m.MIPSGData_asciiz('"\\n"'), m.MIPS_GDATA_NEWLINE);
    //     ret.addGData(new m.MIPSGData_emptyline());
    //     ret.addGData(new m.MIPSGData_asciiz('"true"'), m.MIPS_GDATA_TRUE);
    //     ret.addGData(new m.MIPSGData_emptyline());
    //     ret.addGData(new m.MIPSGData_asciiz('"false"'), m.MIPS_GDATA_FALSE);
    //     ret.addGData(new m.MIPSGData_emptyline());
    //     //pre-defined function, print integer
    //     ret.addCode(new m.MIPS_lw(m.regs.a0, new m.MIPSAddr_reg(4, m.regs.sp)), m.MIPS_FN_PRINT_INT);
    //     ret.addCode(new m.MIPS_li(m.regs.v0, 1));
    //     ret.addCode(new m.MIPS_syscall());
    //     ret.addCode(new m.MIPS_jr(m.regs.ra));
    //     ret.addCode(new m.MIPS_emptyline());
    //     //pre-defined function, print boolean
    //     ret.addCode(new m.MIPS_lw(m.regs.a0, new m.MIPSAddr_reg(4, m.regs.sp)), m.MIPS_FN_PRINT_BOOL);
    //     let endlabel = new CodeLabel(this._labelidgen.next()).toString(), falselabel = new CodeLabel(this._labelidgen.next()).toString();
    //     ret.addCode(new m.MIPS_beqz(m.regs.a0, falselabel));
    //     ret.addCode(new m.MIPS_la(m.regs.a0, m.MIPS_GDATA_TRUE));
    //     ret.addCode(new m.MIPS_b(endlabel));
    //     ret.addCode(new m.MIPS_la(m.regs.a0, m.MIPS_GDATA_FALSE), falselabel);
    //     ret.addCode(new m.MIPS_li(m.regs.v0, 4), endlabel);
    //     ret.addCode(new m.MIPS_syscall());
    //     ret.addCode(new m.MIPS_jr(m.regs.ra));
    //     ret.addCode(new m.MIPS_emptyline());
    //     //pre-defined function, print new-line
    //     ret.addCode(new m.MIPS_la(m.regs.a0, m.MIPS_GDATA_NEWLINE), m.MIPS_FN_PRINT_NEWLINE);
    //     ret.addCode(new m.MIPS_li(m.regs.v0, 4));
    //     ret.addCode(new m.MIPS_syscall());
    //     ret.addCode(new m.MIPS_jr(m.regs.ra));
    //     ret.addCode(new m.MIPS_emptyline());

    //     for (let gd of this._gdatapieces)
    //         gd.toMIPS(ret);
    //     for (let cp of this._codepieces)
    //         cp.toMIPS(ret);
    //     return ret;
    // }
    newCodePiece(fndef: util.FunctionDefinition): CodePiece {
        let ret = new CodePiece(fndef.signiture, fndef.argtypelist.length, this._labelidgen);
        this._codepieces.push(ret);
        return ret;
    }
    toString(): string {
        let gdata = '.data\r\n' + this._gdatapieces.map(gdata => gdata.toString()).join('\r\n\r\n');
        let text = '.text\r\n' + this._codepieces.map(cp => cp.toString()).join('\r\n\r\n');
        return gdata + '\r\n\r\n' + text;
    }
    // addGData(gdata: GDATA): this {
    //     this._gdatapieces.push(gdata);
    //     return this;
    // }
    optimzie(): this {
        for (let cp of this._codepieces) cp.optimize();
        return this;
    }
    constructor() {
        this._codepieces = new Array<CodePiece>();
        //this._gdatapieces = new Array<GDATA>();
        this._labelidgen = new utility.IdGen();
    }
}

// function lineNum2Str(linenum: number, minlen: number): string {
//     let linestr = linenum + ':';
//     let arr = new Array<string>(Math.max(minlen - linestr.length, 0) + 1);
//     for (let i = 0; i < arr.length - 1; ++i) arr[i] = ' ';
//     arr[arr.length - 1] = linestr;
//     return arr.join('');
// }
export class TmpRegValueInference {
    //for folding
    type: number;  //1:any value, 2: constant, 3: constant times register
    cons: number;
    regnum: number;

    // clone(): RegInfo {
    //     let ret = new RegInfo();
    //     ret.type = this.type;
    //     ret.cons = this.cons;
    //     ret.regnum = this.regnum;
    //     return ret;
    // }
    mergeFrom(froms: Array<TmpRegValueInference>): boolean {
        if (this.type === TmpRegValueInference.TYPE_ANY) return false;
        let cons: number = null, regnum: number = null, type = this.type, rlen = froms.length;
        for (let i = 0; i < rlen; ++i) {
            let r = froms[i];
            if (r.type === TmpRegValueInference.TYPE_ANY) {
                this.type = TmpRegValueInference.TYPE_ANY;
                return true;
            }
            else if (type === TmpRegValueInference.TYPE_NEVER) {
                cons = r.cons;
                regnum = r.regnum;
                type = r.type;
            }
            else if (r.type === TmpRegValueInference.TYPE_CONST) {
                //here type must be CONST or CONST_TIMES_REG
                if (type !== TmpRegValueInference.TYPE_CONST || cons !== r.cons) {
                    this.type = TmpRegValueInference.TYPE_ANY;
                    return true;
                }
            }
            else if (r.type === TmpRegValueInference.TYPE_CONST_TIMES_REG) {
                if (type !== TmpRegValueInference.TYPE_CONST_TIMES_REG || regnum !== r.regnum || cons !== r.cons) {
                    this.type = TmpRegValueInference.TYPE_ANY;
                    return true;
                }
            }
        }
        if (this.type === type) return false;
        else {
            this.type = type;
            this.cons = cons;
            this.regnum = regnum;
            return true;
        }
    }
    constructor() {
        this.type = RegInfo.TYPE_NEVER;
    }

    static TYPE_NEVER = 0;
    static TYPE_ANY = 1;
    static TYPE_CONST = 2;
    static TYPE_CONST_TIMES_REG = 3;
}

// export function fnLabel(fnsigniture: string): string {
//     if (fnsigniture === 'main') return fnsigniture;
//     else if (fnsigniture === tc.predefinedFn.print_int.signiture) return m.MIPS_FN_PRINT_INT;
//     else if (fnsigniture === tc.predefinedFn.print_bool.signiture) return m.MIPS_FN_PRINT_BOOL;
//     else if (fnsigniture === tc.predefinedFn.print_newline.signiture) return m.MIPS_FN_PRINT_NEWLINE;
//     else return 'fnlabel_' + fnsigniture;
// }

// export function gdataLabel(labelname: string): string {
//     return 'gdata_' + labelname;
// }

export class CodePiece {
    private _codelines: Array<CodeLine>;
    private _labelidgen: utility.IdGen;
    private _fnlabel: string;
    //private _transinfo: Array<TransInfo>;
    private _plen: number;
    private _retlabel: string;

    private _stopgrow: boolean;
    private _vinfer: boolean;
    private _livessinfer: boolean;

    // toMIPS(asm: m.MIPSAssembly): this {
    //     let regallocret = this.regalloc(), regset = new Set<number>();
    //     for (let x of regallocret.regmap) regset.add(x[1]);
    //     let mipsregs = [...regset].map(rnum => r.regnumToMIPSReg(rnum));
    //     let rlen = mipsregs.length, ismain = this._fnlabel === 'main';
    //     //store the $ra
    //     //store the $fp
    //     if (!ismain) {
    //         asm.addCode(new m.MIPS_sw(m.regs.fp, new m.MIPSAddr_reg(-4 * rlen - 4, m.regs.sp)), this._fnlabel);
    //         asm.addCode(new m.MIPS_sw(m.regs.ra, new m.MIPSAddr_reg(-4 * rlen, m.regs.sp)));
    //         for (let i = 0; i < rlen; ++i) {
    //             //save the value of assigned register into stack
    //             asm.addCode(new m.MIPS_sw(mipsregs[i], new m.MIPSAddr_reg(-4 * i, m.regs.sp)));
    //         }
    //         //reset $fp
    //         asm.addCode(new m.MIPS_add(m.regs.fp, m.regs.sp, -4 * rlen - 8));
    //     }
    //     else {
    //         //reset $fp for main function
    //         asm.addCode(new m.MIPS_move(m.regs.fp, m.regs.sp), this._fnlabel);
    //         //go to virtual table initialization procedure
    //         asm.addCode(new m.MIPS_jal(m.MIPS_VTABLE_INIT_LABEL));
    //     }
    //     //temporary 0 ~ plen-1 are assigned to parameters;
    //     for (let i = 0; i < this._plen; ++i) {
    //         if (regallocret.regmap.has(i))
    //             asm.addCode(new m.MIPS_lw(r.regnumToMIPSReg(regallocret.regmap.get(i)), new m.MIPSAddr_reg(4 + 4 * i, m.regs.sp)));
    //         else if (regallocret.tmpinstack.has(i)) {
    //             //$t9 is a hard coded temporary register to pass value
    //             asm.addCode(new m.MIPS_lw(m.regs.v0, new m.MIPSAddr_reg(4 + 4 * i, m.regs.sp)));
    //             asm.addCode(new m.MIPS_sw(m.regs.v0, new m.MIPSAddr_reg(regallocret.tmpinstack.get(i), m.regs.fp)))
    //         }
    //         else console.log('warn: dead parameter at idx: ' + i);
    //     }
    //     //reset $sp
    //     if (!ismain)
    //         asm.addCode(new m.MIPS_add(m.regs.sp, m.regs.sp, -4 * rlen - 8 - 4 * regallocret.tmpinstack.size));
    //     else if (regallocret.tmpinstack.size > 0)
    //         asm.addCode(new m.MIPS_add(m.regs.sp, m.regs.sp, - 4 * regallocret.tmpinstack.size));
    //     //function body
    //     let clen = this._codelines.length;
    //     for (let i = 0; i < clen; ++i) {
    //         this._codelines[i].toMIPS(asm, regallocret.regmap, i, this._codelines, this._retlabel);
    //     }
    //     if (!ismain) {
    //         asm.addCode(new m.MIPS_lw(m.regs.ra, new m.MIPSAddr_reg(8, m.regs.fp)), this._retlabel);
    //         for (let i = 0; i < rlen; ++i) {
    //             //restore the callee saved register from stack
    //             asm.addCode(new m.MIPS_lw(mipsregs[rlen - 1 - i], new m.MIPSAddr_reg(12 + 4 * i, m.regs.fp)));
    //         }
    //         asm.addCode(new m.MIPS_add(m.regs.sp, m.regs.fp, -8 - 4 * rlen));
    //         asm.addCode(new m.MIPS_lw(m.regs.fp, new m.MIPSAddr_reg(4, m.regs.fp)));
    //         asm.addCode(new m.MIPS_jr(m.regs.ra));
    //     }
    //     else {
    //         //syscall 10 for exit
    //         asm.addCode(new m.MIPS_li(m.regs.v0, 10));
    //         asm.addCode(new m.MIPS_syscall());
    //     }
    //     asm.addCode(new m.MIPS_emptyline());
    //     return this;
    // }
    toString(): string {
        return this._fnlabel + '\r\n' + this._codelines.join('\r\n');
    }
    // newTmpRegId(): number {
    //     if (this._stopgrow) throw new Error('cannot call because this CodePiece stops grow');
    //     return this._tmpregid++;
    // }
    addCodeLine(tac: t.TAC, label?: util.CodeLabel): this {
        if (this._stopgrow) throw new Error('cannot call because this CodePiece stops grow');
        this._codelines.push(new CodeLine(tac, this._codelines.length, label));
        return this;
    }
    newLabel(): util.CodeLabel {
        if (this._stopgrow) throw new Error('cannot call because this CodePiece stops grow');
        return new util.CodeLabel(this._labelidgen);
    }
    optimize(): this {
        this.initCodeTransferGraph().valueInference().fold();
        this.livenessInference().livenessProne();
        this.compress().removebranch().compress();
        return this;
    }
    fold(): this {
        if (!this._vinfer) throw new Error('must be called after valueInference');
        let tlen = this._codelines.length;
        let newtacs = new Array<t.TAC>(tlen);
        let stack = [0], stacktop = 1;
        while (stacktop > 0) {
            let codeseq = stack[--stacktop];
            if (newtacs[codeseq] == null) {
                let cl = this._codelines[codeseq];
                // if(tran.tac instanceof TAC_binary_int){
                //     console.log(tran.tac.toString());
                //     console.log(tran.regt_in[4]);
                // }
                let newtac = cl.tac.simplify(cl.regt_in);
                newtacs[codeseq] = newtac;
                if (!(newtac instanceof t.TAC_ret)) {
                    if (newtac instanceof t.TAC_branch) {
                        if (newtac instanceof t.TAC_btrue || newtac instanceof t.TAC_bfalse) {
                            stack[stacktop++] = codeseq + 1;
                        }
                        stack[stacktop++] = newtac.label.codeline.linenum;
                    }
                    else
                        stack[stacktop++] = codeseq + 1;
                }
            }
        }
        for (let i = 0; i < tlen; ++i)
            this._codelines[i].tac = newtacs[i] || new t.TAC_noop();

        return this.finalizeLabelRef();
    }
    livenessInference(): this {
        //from BOTTOM to TOP
        if (!this._stopgrow) throw new Error('must be called after finalizeLabelRef & initCodeTransferGraph');
        this._livessinfer = true;
        let stack = this._codelines.filter(c => c.tac instanceof t.TAC_ret).map(c => c.linenum);
        let stacktop = stack.length, tlen = this._codelines.length;
        while (stacktop > 0) {
            let codeseq = stack[--stacktop];
            let cl = this._codelines[codeseq];
            let extrato = cl.branchToCL();
            let nextinstructions = extrato == null ? [] : [extrato];
            if (codeseq !== tlen - 1) nextinstructions.push(this._codelines[codeseq + 1]);
            if (cl.makeOutputRegLiveness(nextinstructions.map(l => l.liveReg_in || new Set<number>()))) {
                if (cl.bubbleInputRegLiveness()) {
                    let upstream = (codeseq === 0 ? [] : [this._codelines[codeseq - 1]]).concat(cl.branchInCL());
                    for (let s of upstream) {
                        let i = 0;
                        for (; i < stacktop; ++i) {
                            if (stack[i] === s.linenum) break;
                        }
                        if (i === stacktop) stack[stacktop++] = s.linenum;
                    }
                }
            }
        }
        return this;
    }
    livenessProne(): this {
        if (!this._livessinfer) throw new Error('must be called after livenessInfer');
        let tlen = this._codelines.length;
        for (let i = 0; i < tlen; ++i) {
            let cl = this._codelines[i];
            // console.log(cl.tac);
            // console.info(cl.liveReg_out);
            cl.tac = cl.tac.livenessProne(cl.liveReg_out);
        }
        return this;
    }
    //remove unnecessary branch(jump)
    removebranch(): this {
        if (!this._stopgrow) throw new Error('must be called after finalizeLabelRef');
        let clen = this._codelines.length, rep = false;
        for (let i = 0; i < clen - 1; ++i) {
            let cl = this._codelines[i];
            let tac = cl.tac;
            if (tac instanceof t.TAC_branch) {
                //jump to next instruction
                if (tac.label.codeline === this._codelines[i + 1]) {
                    cl.tac = new t.TAC_noop();
                    rep = true;
                }
            }
        }
        return rep ? this.finalizeLabelRef() : this;
    }
    //remove noop instruction
    compress(): this {
        if (!this._stopgrow) throw new Error('must be called after finalizeLabelRef');
        let clen = this._codelines.length, lastcl: CodeLine = null;
        for (let j = clen - 1; j >= 0; --j) {
            let cl = this._codelines[j];
            let tac = cl.tac;
            if (tac instanceof t.TAC_noop) {
                if (cl.label != null) {
                    if (lastcl == null) throw new Error('defensive code, jump to noop till end of CodePiece');
                    if (lastcl.label == null) {
                        lastcl.label = cl.label;
                        cl.label.codeline = lastcl;
                        cl.label = null;
                    }
                    else {
                        for (let ucl of cl.label.upstreams) {
                            let utac = <t.TAC_branch>ucl.tac;
                            utac.label = lastcl.label;
                            lastcl.label.upstreams.push(ucl);
                        }
                    }
                }
            }
            else lastcl = cl;
        }
        this._codelines = this._codelines.filter(cl => !(cl.tac instanceof t.TAC_noop));
        clen = this._codelines.length;
        for (let i = 0; i < clen; ++i)
            this._codelines[i].linenum = i;
        return this.finalizeLabelRef();
    }
    regalloc(): { regmap: Map<number, number>, tmpinstack: Map<number, number> } {
        let rig = new r.RIG();
        for (let cl of this._codelines) {
            rig.addRelateRegs([...cl.liveReg_in]);
            rig.addRelateRegs([...cl.liveReg_out]);
        }
        let allo = rig.allocate(), fpoffset = 0, oldregcount = this._tmpregid, stackoffsetmap = new Map<number, number>();
        while (!allo.succeed) {
            let snum = allo.spill, i = 0;
            //new assigned reg for spilled reg cannot be spilled again (no good solution to this conflict yet)
            if (snum >= oldregcount) throw new Error('undefined behavior, spilled reigster cannot be spilled again: ' + snum);
            let mloc = -4 * fpoffset++;
            stackoffsetmap.set(snum, mloc);
            rig.removeReg(snum);
            for (; i < this._codelines.length; ++i) {
                let cl = this._codelines[i];
                cl.liveReg_in.delete(snum);
                cl.liveReg_out.delete(snum);
                let tac = cl.tac;
                if (tac.readReg(snum)) {
                    let newreg = this._tmpregid++;
                    let newcl = new CodeLine(new t.TAC_lw(d.REG.fp, mloc, newreg), -1);
                    newcl.liveReg_in = new Set<number>(cl.liveReg_in);
                    newcl.liveReg_out = new Set<number>(cl.liveReg_in).add(newreg);
                    this._codelines.splice(i++, 0, newcl);
                    if (cl.label != null) {
                        let lb = cl.label;
                        cl.label = null;
                        newcl.label = lb;
                        lb.codeline = newcl;
                    }
                    tac.replReadReg(snum, newreg);
                    rig.addRelateRegsForOne(newreg, [...cl.liveReg_in]);
                    cl.liveReg_in.add(newreg);
                }
                if (tac.writeReg(snum)) {
                    let newreg = this._tmpregid++;
                    let newcl = new CodeLine(new t.TAC_sw(d.REG.fp, mloc, newreg), -1);
                    newcl.liveReg_out = new Set<number>(cl.liveReg_out);
                    newcl.liveReg_in = new Set<number>(cl.liveReg_out).add(newreg);
                    this._codelines.splice(++i, 0, newcl);
                    tac.replWriteReg(snum, newreg);
                    rig.addRelateRegsForOne(newreg, [...cl.liveReg_out]);
                    cl.liveReg_out.add(newreg);
                }
            }
            allo = rig.allocate(); //try allocate register again
        }
        this.lineNumAlign();
        return { regmap: allo.map, tmpinstack: stackoffsetmap };
    }
    lineNumAlign(): this {
        let len = this._codelines.length;
        for (let i = 0; i < len; ++i)
            this._codelines[i].linenum = i;
        return this;
    }
    constructor(fnsig: util.FunctionSigniture, plen: number, labelidgen: utility.IdGen) {
        this._codelines = new Array<CodeLine>();
        this._tmpregid = 0;
        this._labelidgen = labelidgen;
        this._fnlabel = fnLabel(fnsig);
        this._plen = plen;
        this._retlabel = this.newLabel().toString();

        this._stopgrow = false;
        this._vinfer = false;
        this._livessinfer = false;
    }
}

export class CodeLine {
    linenum: number;
    liveReg_in: Set<number>;
    liveReg_out: Set<number>;

    toMIPS(asm: m.MIPSAssembly, regmap: Map<number, number>, idx: number, codelines: Array<CodeLine>, retlabel: string): this {
        //livetemp: ignore fp, sp, if any
        let ins = this.tac.toMIPSInstruction(regmap, retlabel, idx === codelines.length - 1, [...this.liveReg_in].filter(x => x >= 0));
        let label = this.label == null ? null : this.label.toString();
        if (ins.length === 0) {
            asm.addCode(new m.MIPS_nop(), label);
        }
        else {
            asm.addCode(ins[0], label);
            for (let i = 1; i < ins.length; ++i)
                asm.addCode(ins[i]);
        }
        return this;
    }
    branchInCL(): Array<CodeLine> {
        if (this.label == null) return [];
        else return this.label.upstreams;
    }
    branchToCL(): CodeLine {
        let tac = this.tac;
        if (tac instanceof t.TAC_branch) {
            let retcl = tac.label.codeline;
            if (retcl == null) throw new Error('defensive code, label point to nothing, branchToCL is supposed to be called under label-complete mode');
            return retcl;
        }
        else return null;
    }
    initRegTrace(regcount: number): this {
        this.regt_in = new Array<RegInfo>(regcount);
        this.regt_out = new Array<RegInfo>(regcount);
        for (let i = 0; i < regcount; ++i) {
            this.regt_in[i] = new RegInfo();
            this.regt_out[i] = new RegInfo();
        }
        return this;
    }
    // initRegLiveness(): this {
    //     this.liveReg_in = new Set<number>();
    //     this.liveReg_out = new Set<number>();
    //     return this;
    // }
    //array of {set of number}
    makeOutputRegLiveness(fromcl: Iterable<Iterable<number>>): boolean {
        let lreg_out = this.liveReg_out, changed = false;
        let lives = new Set<number>();
        for (let s of fromcl)
            for (let l of s)
                lives.add(l);
        if (lreg_out == null) {
            this.liveReg_out = lives;
            changed = true;
        }
        else {
            for (let l of lives) {
                if (!lreg_out.has(l)) {
                    lreg_out.add(l);
                    changed = true;
                }
            }
        }
        return changed;
    }
    bubbleInputRegLiveness(): boolean {
        let outset = this.liveReg_out, inset = this.liveReg_in;
        let charr = this.tac.regLiveness(outset), changed = false, tmpset = new Set<number>();
        for (let n of outset) tmpset.add(n);
        for (let c of charr) {
            if (c.live) tmpset.add(c.regnum);
            else tmpset.delete(c.regnum);
        }
        if (inset == null) {
            this.liveReg_in = tmpset;
            changed = true;
        }
        else {
            for (let n of tmpset) {
                if (!inset.has(n)) {
                    inset.add(n);
                    changed = true;
                }
            }
        }
        return changed;
    }
    toString(): string {
        let labelstr = '';
        if (this.label != null)
            labelstr = this.label + ' :\r\n';
        return labelstr + '    ' + this.tac.toString();
    }
    constructor(public tac: t.TAC, public label?: util.CodeLabel) { }
}


//global data block
export abstract class GDATA {
    toString(): string {
        throw new Error('not implemented');
    }
    toMIPS(asm: m.MIPSAssembly): this {
        throw new Error('not implemented');
    }
}
export class GDATA_VTABLE extends GDATA {
    private _vtable: Array<d.FunctionDefinition>;
    private _vtable_label: string;
    constructor(classdef: d.ClassDefinition) {
        super();
        this._vtable = classdef.getVTable();
        this._vtable_label = gdataLabel(classdef.getVTableLabel());
    }
    toString(): string {
        return [this._vtable_label + ' :'].concat(this._vtable.map(fndef => fndef.signiture)).join('\r\n');
    }
    toMIPS(asm: m.MIPSAssembly): this {
        asm.addGData(new m.MIPSGData_word(this._vtable.length), this._vtable_label);
        asm.addGData(new m.MIPSGData_emptyline());
        return this;
    }
}
