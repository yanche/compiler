
import * as utility from 'utility';
import * as t from './tac';
import * as r from './regallocate';
import * as m from './mipscode';
//import * as tc from './typecheck';
import * as util from './util';

//FOR INTERMEDIATE CODE GENERATION AND OPTIMIZATION

function inferTopTmpRegValues(from: Array<CodeLineRegInfoInferences>, to: CodeLineRegInfoInferences): boolean {
    if (from.length === 0) return false;
    let flen = to.top_val.length, changed = false;
    for (let i = 0; i < flen; ++i) {
        let fromslice = from.map(r => r.bottom_val[i]);
        if (to.top_val[i].mergeFrom(fromslice)) changed = true;
    }
    return changed;
}

function inferBottomTmpRegValues(tac: t.TAC, regvinfer: CodeLineRegInfoInferences): boolean {
    let o = tac.inferTmpRegValue(regvinfer.top_val), changed = false, rlen = regvinfer.bottom_val.length;
    for (let i = 0; i < rlen; ++i) {
        if (regvinfer.bottom_val[i].mergeFrom([(o == null || o.regnum !== i) ? regvinfer.top_val[i] : o.reginfo])) changed = true;
    }
    return changed;
}

function valueInference(codelines: Array<CodeLine>, regvinfer: Array<CodeLineRegInfoInferences>) {
    let clen = codelines.length;
    for (let i = 0; i < clen; ++i)codelines[i].linenum = i;
    let stack = [0], stacktop = 1, first = true;
    while (stacktop > 0) {
        let codeseq = stack[--stacktop];
        let cl = codelines[codeseq], clregvinfer = regvinfer[codeseq];
        let from = cl.branchInCL();
        if (codeseq > 0) from = from.concat(codelines[codeseq - 1]);
        if (first || inferTopTmpRegValues(from.map(n => regvinfer[n.linenum]), clregvinfer)) {
            first = false;
            if (inferBottomTmpRegValues(cl.tac, clregvinfer)) {
                let extrato = cl.branchToCL();
                let tocodelines = extrato == null ? [] : [extrato];
                if (codeseq !== clen - 1)
                    tocodelines.push(codelines[codeseq + 1]);
                for (let cl of tocodelines) {
                    let j = 0, linenum = cl.linenum;
                    for (; j < stacktop; ++j) {
                        if (stack[j] === linenum) break;
                    }
                    //to be processed
                    if (j === stacktop) stack[stacktop++] = linenum;
                }
            }
        }
    }
}

function valueFold(codelines: Array<CodeLine>, regvinfer: Array<CodeLineRegInfoInferences>) {
    let tlen = codelines.length;
    let newtacs = new Array<t.TAC>(tlen);
    let stack = [0], stacktop = 1;
    while (stacktop > 0) {
        let codeseq = stack[--stacktop];
        if (newtacs[codeseq] == null) {
            let cl = codelines[codeseq];
            let newtac = cl.tac.simplify(regvinfer[codeseq].top_val);
            newtacs[codeseq] = newtac;
            if (!(newtac instanceof t.TAC_ret)) {
                if (newtac instanceof t.TAC_branch) {
                    //the last TAC must be RET
                    if (newtac instanceof t.TAC_btrue || newtac instanceof t.TAC_bfalse)
                        stack[stacktop++] = codeseq + 1;
                    stack[stacktop++] = newtac.label.owner.linenum;
                }
                else
                    stack[stacktop++] = codeseq + 1;
            }
        }
    }
    for (let i = 0; i < tlen; ++i)
        codelines[i].tac = newtacs[i] || new t.TAC_noop();
}

function livenessInference(codelines: Array<CodeLine>, regvinfer: Array<CodeLineRegInfoInferences>) {
    //from BOTTOM to TOP
    let clen = codelines.length;
    for (let i = 0; i < clen; ++i)codelines[i].linenum = i;
    let stack = codelines.filter(c => c.tac instanceof t.TAC_ret).map(c => c.linenum);
    let stacktop = stack.length;
    while (stacktop > 0) {
        let codeseq = stack[--stacktop];
        let cl = codelines[codeseq];
        let extrato = cl.branchToCL();
        let nexts = extrato == null ? [] : [extrato.linenum];
        if (codeseq !== clen - 1) nexts.push(codeseq + 1);
        if (inferBottomTmpRegLiveness(nexts.map(i => regvinfer[i].top_live || new Set<number>()), regvinfer[codeseq])) {
            if (inferTopTmpRegLiveness(cl.tac, regvinfer[codeseq])) {
                let upstream = (codeseq === 0 ? [] : [codeseq - 1]).concat(cl.branchInCL().map(l => l.linenum));
                for (let s of upstream) {
                    let i = 0;
                    for (; i < stacktop; ++i) {
                        if (stack[i] === s) break;
                    }
                    if (i === stacktop) stack[stacktop++] = s;
                }
            }
        }
    }
}

function inferBottomTmpRegLiveness(fromcl: Iterable<Iterable<number>>, regvinfer: CodeLineRegInfoInferences): boolean {
    let changed = false, lives = new Set<number>();
    for (let s of fromcl)
        for (let l of s)
            lives.add(l);
    if (regvinfer.bottom_live == null) {
        regvinfer.bottom_live = lives;
        changed = true;
    }
    else {
        for (let l of lives) {
            if (!regvinfer.bottom_live.has(l)) {
                regvinfer.bottom_live.add(l);
                changed = true;
            }
        }
    }
    return changed;
}

function inferTopTmpRegLiveness(tac: t.TAC, regvinfer: CodeLineRegInfoInferences): boolean {
    let charr = tac.tmpRegLiveness(regvinfer.bottom_live), changed = false, tmpset = new Set<number>(regvinfer.bottom_live);
    for (let c of charr) {
        if (c.live) tmpset.add(c.regnum);
        else tmpset.delete(c.regnum);
    }
    if (regvinfer.top_live == null) {
        regvinfer.top_live = tmpset;
        changed = true;
    }
    else {
        for (let n of tmpset) {
            if (!regvinfer.top_live.has(n)) {
                regvinfer.top_live.add(n);
                changed = true;
            }
        }
    }
    return changed;
}

function livenessProne(codelines: Array<CodeLine>, regvinfer: Array<CodeLineRegInfoInferences>) {
    let tlen = codelines.length;
    for (let i = 0; i < tlen; ++i) {
        let cl = codelines[i];
        cl.tac = cl.tac.livenessProne(regvinfer[i].bottom_live);
    }
}

//remove unnecessary branch(jump)
function removeBranch(codelines: Array<CodeLine>) {
    let clen = codelines.length;
    for (let i = 0; i < clen; ++i)codelines[i].linenum = i;
    for (let i = 0; i < clen - 1; ++i) {
        let cl = codelines[i];
        let tac = cl.tac;
        if (tac instanceof t.TAC_branch) {
            let tidx = tac.label.owner.linenum;
            if (tidx > i) {
                let j = i + 1;
                //if all instructions before the jump target is NOOP, then this jump is unnecessary
                while (codelines[j].tac instanceof t.TAC_noop && j < tidx)++j;
                if (j === tidx)
                    cl.tac = new t.TAC_noop();
            }
        }
    }
    finalizeLabelRef(codelines);
}

//remove noop instruction
function compress(codelines: Array<CodeLine>): Array<CodeLine> {
    let clen = codelines.length, lastcl: CodeLine = null;
    for (let j = clen - 1; j >= 0; --j) {
        let cl = codelines[j];
        let tac = cl.tac;
        if (tac instanceof t.TAC_noop) {
            if (cl.label != null) {
                if (lastcl == null) throw new Error('defensive code, jump to noop till end of code');
                if (lastcl.label == null) {
                    lastcl.label = cl.label;
                    cl.label.owner = lastcl;
                    cl.label = null;
                }
                else {
                    for (let ucl of cl.label.upstreams) {
                        let utac = <t.TAC_branch>ucl.tac;
                        utac.label = lastcl.label;
                    }
                }
            }
        }
        else lastcl = cl;
    }
    let ret = codelines.filter(cl => !(cl.tac instanceof t.TAC_noop));
    finalizeLabelRef(ret);
    return ret;
}

function finalizeLabelRef(codelines: Array<CodeLine>) {
    for (let cl of codelines)
        if (cl.label != null)
            cl.label.upstreams = new Array<CodeLine>();
    for (let cl of codelines) {
        let tac = cl.tac;
        if (tac instanceof t.TAC_branch)
            tac.label.upstreams.push(cl);
    }
    for (let cl of codelines) {
        if (cl.label != null) {
            if (cl.label.upstreams.length > 0)
                cl.label.owner = cl;
            else
                cl.label = null;
        }
    }
}

export function generateIntermediateCode(classlookup: util.ClassLookup, fnlookup: util.FunctionLookup): IntermediateCode {
    let code = new IntermediateCode();
    for (let classname of classlookup.getAllClasses().concat(null)) {
        let classdef = classlookup.getClass(classname);
        for (let fndef of fnlookup.findMethods(classname)) {
            if (fndef.astnode == null) continue;
            let codelines = new CodeLineCollector();
            fndef.astnode.genIntermediateCode(codelines);
            finalizeLabelRef(codelines._arr);
            let cllen = codelines._arr.length;
            //each code-line would have one reg-info-inference record (one for input one for output)
            let clvalueinfer = new Array<CodeLineRegInfoInferences>(cllen);
            for (let i = 0; i < cllen; ++i)
                clvalueinfer[i] = new CodeLineRegInfoInferences(fndef.astnode.tmpRegAssigned);
            console.log('parameter tmp register for: ' + fndef.name);
            console.log(fndef.astnode.argTmpRegIdList);
            //set the value type of arguments to 'ANY'
            for (let i of fndef.astnode.argTmpRegIdList)
                clvalueinfer[0].top_val[i].type = TmpRegValueInference.TYPE_ANY;
            valueInference(codelines._arr, clvalueinfer);
            valueFold(codelines._arr, clvalueinfer); //fold will replace several TAC
            livenessInference(codelines._arr, clvalueinfer);
            livenessProne(codelines._arr, clvalueinfer); //livenessProne will replace several TAC
            removeBranch(codelines._arr);
            //final code-lines
            let fcl = compress(codelines._arr);
            code.newCodePiece(fndef, fcl);
        }
    }
    return code;
}

class CodeLineRegInfoInferences {
    top_val: Array<TmpRegValueInference>;
    bottom_val: Array<TmpRegValueInference>;
    top_live: Set<number>;
    bottom_live: Set<number>;
    constructor(regcount: number) {
        this.top_val = new Array<TmpRegValueInference>();
        this.bottom_val = new Array<TmpRegValueInference>();
        this.top_live = null;
        this.bottom_live = null;
    }
}

export class CodeLineCollector {
    _arr: Array<CodeLine>;
    add(tac: t.TAC, label?: util.CodeLabel): this {
        this._arr.push(new CodeLine(tac, label));
        return this;
    }
    constructor() {
        this._arr = new Array<CodeLine>();
    }
}

export class IntermediateCode {
    private _codepieces: Array<CodePiece>;
    //private _gdatapieces: Array<GDATA>;
    private _labelidgen: utility.IdGen;

    toMIPS(classlookup: util.ClassLookup): m.MIPSAssembly {
        for (let gd of this._gdatapieces)
            gd.toMIPS(ret);
        for (let cp of this._codepieces)
            cp.toMIPS(ret);
        return ret;
    }
    newCodePiece(fndef: util.FunctionDefinition, codelines: Array<CodeLine>): this {
        this._codepieces.push(new CodePiece(fndef, codelines));
        return this;
    }
    toString(): string {
        let gdata = '.data\r\n' + this._gdatapieces.map(gdata => gdata.toString()).join('\r\n\r\n');
        let text = '.text\r\n' + this._codepieces.map(cp => cp.toString()).join('\r\n\r\n');
        return gdata + '\r\n\r\n' + text;
    }
    // addGData(gdata: GDATA): this {
    //     this._gdatapieces.push(gdata);
    //     return this;
    // }
    constructor() {
        this._codepieces = new Array<CodePiece>();
        //this._gdatapieces = new Array<GDATA>();
        this._labelidgen = new utility.IdGen();
    }
}

// function lineNum2Str(linenum: number, minlen: number): string {
//     let linestr = linenum + ':';
//     let arr = new Array<string>(Math.max(minlen - linestr.length, 0) + 1);
//     for (let i = 0; i < arr.length - 1; ++i) arr[i] = ' ';
//     arr[arr.length - 1] = linestr;
//     return arr.join('');
// }

export class TmpRegValueInference {
    //for folding
    type: number;  //1:any value, 2: constant, 3: constant times register
    cons: number;
    regnum: number;

    // clone(): RegInfo {
    //     let ret = new RegInfo();
    //     ret.type = this.type;
    //     ret.cons = this.cons;
    //     ret.regnum = this.regnum;
    //     return ret;
    // }
    mergeFrom(froms: Array<TmpRegValueInference>): boolean {
        if (this.type === TmpRegValueInference.TYPE_ANY) return false;
        let cons: number = null, regnum: number = null, type = this.type, rlen = froms.length;
        for (let i = 0; i < rlen; ++i) {
            let r = froms[i];
            if (r.type === TmpRegValueInference.TYPE_ANY) {
                this.type = TmpRegValueInference.TYPE_ANY;
                return true;
            }
            else if (type === TmpRegValueInference.TYPE_NEVER) {
                cons = r.cons;
                regnum = r.regnum;
                type = r.type;
            }
            else if (r.type === TmpRegValueInference.TYPE_CONST) {
                //here type must be CONST or CONST_TIMES_REG
                if (type !== TmpRegValueInference.TYPE_CONST || cons !== r.cons) {
                    this.type = TmpRegValueInference.TYPE_ANY;
                    return true;
                }
            }
            else if (r.type === TmpRegValueInference.TYPE_CONST_TIMES_REG) {
                if (type !== TmpRegValueInference.TYPE_CONST_TIMES_REG || regnum !== r.regnum || cons !== r.cons) {
                    this.type = TmpRegValueInference.TYPE_ANY;
                    return true;
                }
            }
        }
        if (this.type === type) return false;
        else {
            this.type = type;
            this.cons = cons;
            this.regnum = regnum;
            return true;
        }
    }
    constructor() {
        this.type = TmpRegValueInference.TYPE_NEVER;
    }

    static TYPE_NEVER = 0;
    static TYPE_ANY = 1;
    static TYPE_CONST = 2;
    static TYPE_CONST_TIMES_REG = 3;
}

// export function fnLabel(fnsigniture: string): string {
//     if (fnsigniture === 'main') return fnsigniture;
//     else if (fnsigniture === tc.predefinedFn.print_int.signiture) return m.MIPS_FN_PRINT_INT;
//     else if (fnsigniture === tc.predefinedFn.print_bool.signiture) return m.MIPS_FN_PRINT_BOOL;
//     else if (fnsigniture === tc.predefinedFn.print_newline.signiture) return m.MIPS_FN_PRINT_NEWLINE;
//     else return 'fnlabel_' + fnsigniture;
// }

// export function gdataLabel(labelname: string): string {
//     return 'gdata_' + labelname;
// }

export class CodePiece {
    private _codelines: Array<CodeLine>;
    private _fndef: util.FunctionDefinition;

    // toMIPS(asm: m.MIPSAssembly): this {
    //     let regallocret = this.regalloc(), regset = new Set<number>();
    //     for (let x of regallocret.regmap) regset.add(x[1]);
    //     let mipsregs = [...regset].map(rnum => r.regnumToMIPSReg(rnum));
    //     let rlen = mipsregs.length, ismain = this._fnlabel === 'main';
    //     //store the $ra
    //     //store the $fp
    //     if (!ismain) {
    //         asm.addCode(new m.MIPS_sw(m.regs.fp, new m.MIPSAddr_reg(-4 * rlen - 4, m.regs.sp)), this._fnlabel);
    //         asm.addCode(new m.MIPS_sw(m.regs.ra, new m.MIPSAddr_reg(-4 * rlen, m.regs.sp)));
    //         for (let i = 0; i < rlen; ++i) {
    //             //save the value of assigned register into stack
    //             asm.addCode(new m.MIPS_sw(mipsregs[i], new m.MIPSAddr_reg(-4 * i, m.regs.sp)));
    //         }
    //         //reset $fp
    //         asm.addCode(new m.MIPS_add(m.regs.fp, m.regs.sp, -4 * rlen - 8));
    //     }
    //     else {
    //         //reset $fp for main function
    //         asm.addCode(new m.MIPS_move(m.regs.fp, m.regs.sp), this._fnlabel);
    //         //go to virtual table initialization procedure
    //         asm.addCode(new m.MIPS_jal(m.MIPS_VTABLE_INIT_LABEL));
    //     }
    //     //temporary 0 ~ plen-1 are assigned to parameters;
    //     for (let i = 0; i < this._plen; ++i) {
    //         if (regallocret.regmap.has(i))
    //             asm.addCode(new m.MIPS_lw(r.regnumToMIPSReg(regallocret.regmap.get(i)), new m.MIPSAddr_reg(4 + 4 * i, m.regs.sp)));
    //         else if (regallocret.tmpinstack.has(i)) {
    //             //$t9 is a hard coded temporary register to pass value
    //             asm.addCode(new m.MIPS_lw(m.regs.v0, new m.MIPSAddr_reg(4 + 4 * i, m.regs.sp)));
    //             asm.addCode(new m.MIPS_sw(m.regs.v0, new m.MIPSAddr_reg(regallocret.tmpinstack.get(i), m.regs.fp)))
    //         }
    //         else console.log('warn: dead parameter at idx: ' + i);
    //     }
    //     //reset $sp
    //     if (!ismain)
    //         asm.addCode(new m.MIPS_add(m.regs.sp, m.regs.sp, -4 * rlen - 8 - 4 * regallocret.tmpinstack.size));
    //     else if (regallocret.tmpinstack.size > 0)
    //         asm.addCode(new m.MIPS_add(m.regs.sp, m.regs.sp, - 4 * regallocret.tmpinstack.size));
    //     //function body
    //     let clen = this._codelines.length;
    //     for (let i = 0; i < clen; ++i) {
    //         this._codelines[i].toMIPS(asm, regallocret.regmap, i, this._codelines, this._retlabel);
    //     }
    //     if (!ismain) {
    //         asm.addCode(new m.MIPS_lw(m.regs.ra, new m.MIPSAddr_reg(8, m.regs.fp)), this._retlabel);
    //         for (let i = 0; i < rlen; ++i) {
    //             //restore the callee saved register from stack
    //             asm.addCode(new m.MIPS_lw(mipsregs[rlen - 1 - i], new m.MIPSAddr_reg(12 + 4 * i, m.regs.fp)));
    //         }
    //         asm.addCode(new m.MIPS_add(m.regs.sp, m.regs.fp, -8 - 4 * rlen));
    //         asm.addCode(new m.MIPS_lw(m.regs.fp, new m.MIPSAddr_reg(4, m.regs.fp)));
    //         asm.addCode(new m.MIPS_jr(m.regs.ra));
    //     }
    //     else {
    //         //syscall 10 for exit
    //         asm.addCode(new m.MIPS_li(m.regs.v0, 10));
    //         asm.addCode(new m.MIPS_syscall());
    //     }
    //     asm.addCode(new m.MIPS_emptyline());
    //     return this;
    // }
    toString(): string {
        return this._fnlabel + '\r\n' + this._codelines.join('\r\n');
    }
    regalloc(): { regmap: Map<number, number>, tmpinstack: Map<number, number> } {
        let rig = new r.RIG();
        for (let cl of this._codelines) {
            rig.addRelateRegs([...cl.liveReg_in]);
            rig.addRelateRegs([...cl.liveReg_out]);
        }
        let allo = rig.allocate(), fpoffset = 0, oldregcount = this._tmpregid, stackoffsetmap = new Map<number, number>();
        while (!allo.succeed) {
            let snum = allo.spill, i = 0;
            //new assigned reg for spilled reg cannot be spilled again (no good solution to this conflict yet)
            if (snum >= oldregcount) throw new Error('undefined behavior, spilled reigster cannot be spilled again: ' + snum);
            let mloc = -4 * fpoffset++;
            stackoffsetmap.set(snum, mloc);
            rig.removeReg(snum);
            for (; i < this._codelines.length; ++i) {
                let cl = this._codelines[i];
                cl.liveReg_in.delete(snum);
                cl.liveReg_out.delete(snum);
                let tac = cl.tac;
                if (tac.readReg(snum)) {
                    let newreg = this._tmpregid++;
                    let newcl = new CodeLine(new t.TAC_lw(d.REG.fp, mloc, newreg), -1);
                    newcl.liveReg_in = new Set<number>(cl.liveReg_in);
                    newcl.liveReg_out = new Set<number>(cl.liveReg_in).add(newreg);
                    this._codelines.splice(i++, 0, newcl);
                    if (cl.label != null) {
                        let lb = cl.label;
                        cl.label = null;
                        newcl.label = lb;
                        lb.codeline = newcl;
                    }
                    tac.replReadReg(snum, newreg);
                    rig.addRelateRegsForOne(newreg, [...cl.liveReg_in]);
                    cl.liveReg_in.add(newreg);
                }
                if (tac.writeReg(snum)) {
                    let newreg = this._tmpregid++;
                    let newcl = new CodeLine(new t.TAC_sw(d.REG.fp, mloc, newreg), -1);
                    newcl.liveReg_out = new Set<number>(cl.liveReg_out);
                    newcl.liveReg_in = new Set<number>(cl.liveReg_out).add(newreg);
                    this._codelines.splice(++i, 0, newcl);
                    tac.replWriteReg(snum, newreg);
                    rig.addRelateRegsForOne(newreg, [...cl.liveReg_out]);
                    cl.liveReg_out.add(newreg);
                }
            }
            allo = rig.allocate(); //try allocate register again
        }
        this.lineNumAlign();
        return { regmap: allo.map, tmpinstack: stackoffsetmap };
    }
    constructor(fndef: util.FunctionDefinition, codelines: Array<CodeLine>) {
        this._codelines = codelines;
        this._fndef = fndef;
    }
}

export class CodeLine {
    linenum: number;

    // toMIPS(asm: m.MIPSAssembly, regmap: Map<number, number>, idx: number, codelines: Array<CodeLine>, retlabel: string): this {
    //     //livetemp: ignore fp, sp, if any
    //     let ins = this.tac.toMIPSInstruction(regmap, retlabel, idx === codelines.length - 1, [...this.liveReg_in].filter(x => x >= 0));
    //     let label = this.label == null ? null : this.label.toString();
    //     if (ins.length === 0) {
    //         asm.addCode(new m.MIPS_nop(), label);
    //     }
    //     else {
    //         asm.addCode(ins[0], label);
    //         for (let i = 1; i < ins.length; ++i)
    //             asm.addCode(ins[i]);
    //     }
    //     return this;
    // }
    branchInCL(): Array<CodeLine> {
        if (this.label == null) return [];
        else return this.label.upstreams;
    }
    branchToCL(): CodeLine {
        let tac = this.tac;
        if (tac instanceof t.TAC_branch) {
            let retcl = tac.label.owner;
            if (retcl == null) throw new Error('defensive code, label point to nothing, branchToCL is supposed to be called under label-complete mode');
            return retcl;
        }
        else return null;
    }
    toString(): string {
        let labelstr = '';
        if (this.label != null)
            labelstr = this.label + ' :\r\n';
        return labelstr + this.tac.toString();
    }
    constructor(public tac: t.TAC, public label?: util.CodeLabel) { }
}


//global data block
export abstract class GDATA {
    toString(): string {
        throw new Error('not implemented');
    }
    toMIPS(asm: m.MIPSAssembly): this {
        throw new Error('not implemented');
    }
}
export class GDATA_VTABLE extends GDATA {
    private _vtable: Array<d.FunctionDefinition>;
    private _vtable_label: string;
    constructor(classdef: d.ClassDefinition) {
        super();
        this._vtable = classdef.getVTable();
        this._vtable_label = gdataLabel(classdef.getVTableLabel());
    }
    toString(): string {
        return [this._vtable_label + ' :'].concat(this._vtable.map(fndef => fndef.signiture)).join('\r\n');
    }
    toMIPS(asm: m.MIPSAssembly): this {
        asm.addGData(new m.MIPSGData_word(this._vtable.length), this._vtable_label);
        asm.addGData(new m.MIPSGData_emptyline());
        return this;
    }
}
