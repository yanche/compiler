
MIPS reference:
https://en.wikibooks.org/wiki/MIPS_Assembly
https://en.wikibooks.org/wiki/MIPS_Assembly/Pseudoinstructions
https://yanstorage.blob.core.chinacloudapi.cn/personal/mips tutorial.pdf
https://yanstorage.blob.core.chinacloudapi.cn/personal/MD00082-2B-MIPS32INT-AFP-06.01.pdf




STACK ALLOCATION:
[HIGHER ADDRESS]
PARAMETER N
PARAMETER N-1
.
.
.
PARAMETER 1
STORED REGISTER 1
.
.
.
STORED REGISTER N
RETURN ADDRESS
OLD FRAME POINTER(FP)
[LOWER ADDRESS]



A testing language.

primitives: int bool

class/method

function def/call


SAMPLE:

class A {
    int field1;
    int field2;
    int sum(int num) {
        return field1 + field2 + num;
    }
    A(int f1, int f2) {
        field1 = f1;
        field2 = f2 + 3;
    }
}

class B: A {
    int field3;
    int sum(int num) {
        return field1 + field2 + field3 + num;
    }
    B(int f3) {
        super(f3 + 1, f3 + 2);
        field3 = f3;
    }
}

void main() {
    A a = new A(10, 20);
    a.sum(5);

    A b = new B(30);
    b.sum(20);
}

int sum(int x, int y) {
    return x + y;
}





GRAMMAR:

PROGRAM -> GLOBAL-STATEMENT-LIST
GLOBAL-STATEMENT-LIST -> GLOBAL-STATEMENT GLOBAL-STATEMENT-LIST | GLOBAL-STATEMENT
GLOBAL-STATEMENT -> FUNCTION-DEFINITION | CLASS-DEFINITION
FUNCTION-DEFINITION -> void id FUNCTION-DEFINITION-MAIN | TYPE-ANNOTATION id FUNCTION-DEFINITION-MAIN
FUNCTION-DEFINITION-MAIN -> ( ARGUMENT-NULLABLE-LIST ) { NULLABLE-STATEMENT-LIST }
NULLABLE-STATEMENT-LIST -> | STATEMENT-LIST
TYPE-ANNOTATION -> id | id [ ]
ARGUMENT-NULLABLE-LIST -> ARGUMENT-LIST | 
ARGUMENT-LIST -> VAR-DECLARATION , ARGUMENT-LIST | VAR-DECLARATION
VAR-DECLARATION -> TYPE-ANNOTATION id
CLASS-DEFINITION -> class id CLASS-EXTENSION { CLASS-BODY }
CLASS-EXTENSION -> | : id
CLASS-BODY -> CLASS-BODY-ITEM CLASS-BODY | CLASS-BODY-ITEM
CLASS-BODY-ITEM -> VAR-DECLARATION ; | FUNCTION-DEFINITION | constructor FUNCTION-DEFINITION-MAIN
STATEMENT-LIST -> STATEMENT STATEMENT-LIST | STATEMENT
STATEMENT -> NOT-IF-STATEMENT | IF-STATEMENT
NOT-IF-STATEMENT -> ; | EXPRESSION ; | { STATEMENT-LIST } | return ; | return EXPRESSION ; | LOOP-STATEMENT | TYPE-ANNOTATION id = EXPRESSION ;
LOOP-STATEMENT -> while ( EXPRESSION ) STATEMENT | for ( FOR-LOOP-INIT ; EXPRESSION ; NULLABLE-EXPRESSION ) STATEMENT | do STATEMENT while ( EXPRESSION )
FOR-LOOP-INIT -> | EXPRESSION | TYPE-ANNOTATION id = EXPRESSION
NULLABLE-EXPRESSION -> | EXPRESSION
IF-STATEMENT -> MATCHED-IF-STATEMENT | UNMATCHED-IF-STATEMENT
MATCHED-IF-STATEMENT -> if ( EXPRESSION ) STATEMENT-WITH-ELSE else STATEMENT-WITH-ELSE
STATEMENT-WITH-ELSE -> MATCHED-IF-STATEMENT | NOT-IF-STATEMENT
UNMATCHED-IF-STATEMENT -> if ( EXPRESSION ) STATEMENT | if ( EXPRESSION ) STATEMENT-WITH-ELSE else UNMATCHED-IF-STATEMENT
EXPRESSION -> LVAL = EXPRESSION | OR-EXPRESSION
LVAL -> LVAL-NODE | LVAL . LVAL-NODE
LVAL-NODE -> id | id [ EXPRESSION ]
OR-EXPRESSION -> AND-EXPRESSION || AND-EXPRESSION | AND-EXPRESSION
AND-EXPRESSION -> TESTER-EXPRESSION && TESTER-EXPRESSION | TESTER-EXPRESSION
TESTER-EXPRESSION -> BOOP-EXPRESSION TESTER BOOP-EXPRESSION | BOOP-EXPRESSION
TESTER -> == | >= | <= | > | <
BOOP-EXPRESSION -> SHIFT-EXPRESSION BOOP SHIFT-EXPRESSION | SHIFT-EXPRESSION
BOOP -> & | |
SHIFT-EXPRESSION -> ADD-EXPRESSION SHIFT ADD-EXPRESSION | ADD-EXPRESSION
SHIFT -> << | >> | >>>
ADD-EXPRESSION -> MULT-EXPRESSION ADD MULT-EXPRESSION | MULT-EXPRESSION
ADD -> + | -
MULT-EXPRESSION -> CALL-EXPRESSION MULT CALL-EXPRESSION | CALL-EXPRESSION
MULT -> * | /
CALL-EXPRESSION -> FN-NAME ( EXPRESSION-NULLABLE-LIST ) | new id ( EXPRESSION-NULLABLE-LIST ) | new id [ EXPRESSION ] | UNARY-EXPRESSION
UNARY-EXPRESSION -> UNARY DIRECT-VAL | DIRECT-VAL | ( EXPRESSION )
UNARY -> ! | ~ | -
FN-NAME -> LVAL | super
DIRECT-VAL -> LVAL | LITERAL
LITERAL -> integer | boolean
EXPRESSION-NULLABLE-LIST -> EXPRESSION-LIST | 
EXPRESSION-LIST -> EXPRESSION , EXPRESSION-LIST | EXPRESSION
