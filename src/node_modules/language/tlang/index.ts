
import lex from './lex';
import pt2ast from './pt2ast';
import parser from './parser';
import * as c from 'compile';
import * as fs from 'fs';
import * as sm from './semantic';
import * as ap from './astprocess';
import * as utility from 'utility';
import * as d from './def';
import * as ic from './intermediatecode';


function compile(input: string, icpath: string, optimizedicpath: string, mipspath: string): Promise<c.CompileReturn> {
    return Promise.resolve().then(() => {
        let lexret = lex(input, parser.prodset);
        if (!lexret.accept) return new c.CompileReturn(false, lexret.errmsg, lexret.errcode);
        let parseret = parser.parse(lexret.tokens);
        if (!parseret.accept) return new c.CompileReturn(false, parseret.errmsg, parseret.errcode);
        let ast = <ap.ASTNode_globaldefs>pt2ast.toAST(parseret.root);
        let classlookup = new d.ClassLookup();
        let fnlookup = new d.FunctionLookup(classlookup);
        let tret = sm.analysize(ast, classlookup, fnlookup);
        if (!tret.accept) return new c.CompileReturn(false, tret.errmsg, tret.errcode);
        // let mret = ast.completenesscheck(true);
        // if (!mret.accept) return new c.CompileReturn(false, mret.errmsg, mret.errcode);
        let code = new ic.IntermediateCode();
        ast.genIntermediateCode(code);
        return utility.file.writeFile(icpath, code.toString())
            .then(() => utility.file.writeFile(optimizedicpath, code.optimzie().toString()))
            .then(() => utility.file.writeFile(mipspath, code.toMIPS(classlookup).toString()))
            .then(() => new c.CompileReturn(true));
    }).catch((err: Error) => new c.CompileReturn(false, 'failed to write intermediate code into given file: \n' + err.stack, 0));
}

function _compileFromFile(srcfilepath: string, icpath: string, optimizedicpath: string, mipspath: string): Promise<c.CompileReturn> {
    return utility.file.readFile(srcfilepath).then((data: Buffer) => compile(data.toString('utf8'), icpath, optimizedicpath, mipspath));
}

export function compileFromFile(srcfilepath: string): Promise<c.CompileReturn> {
    return utility.file.readFile(srcfilepath).then((data: Buffer) => compile(data.toString('utf8'), srcfilepath + '.ic', srcfilepath + '.optimized.ic', srcfilepath + '.asm'));
}
