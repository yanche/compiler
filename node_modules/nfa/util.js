
var utility = require('utility');

var calcEpsilonClosure = function (states) {
    var smap = new Map(), slen = states.length;
    if(slen == 0) return;
    for(var i = 0; i < slen; ++i) {
        var state = states[i];
        if(smap.has(state)) throw new Error('duplicate states in given array');
        else smap.set(state, 0); //0:white, 1:grey: 2:black
    }
    var blackIdx = 0; //for index < blackIdx it's all in black color
    while(blackIdx < slen) {
        calcThruState([], 0, states[blackIdx], smap);
        while(blackIdx < slen && smap.get(states[blackIdx]) == 2) ++blackIdx;
    }
};

//state is in white color
var calcThruState = function (stack, stackTop, state, colorMap) {
    stack[stackTop] = state;
    addStatesToClosure(stack, 0, stackTop, [state]);

    colorMap.set(state, 1); //grey: in stack, processing
    var eptrans = state.getTransition('');
    if(eptrans != null) {
        var valsGen = eptrans.values();
        var v = valsGen.next();
        while(!v.done) {
            var adjstate = v.value;
            if(adjstate != state) {
                var adjcolor = colorMap.get(adjstate);
                var adjclosure = adjstate.getEpsilonClosure();
                if(adjcolor == 2) {
                    //adj state is black
                    addStatesToClosure(stack, 0, stackTop, adjclosure.getStates());
                }
                else if(adjcolor == 1) {
                    //adj state is grey
                    var adjidx = 0;
                    while(adjidx <= stackTop && stack[adjidx] != adjstate) adjidx++;
                    if(adjidx > stackTop)
                        throw new Error('impossible code path, cannot find grey adjstate in stack');
                    var idx = adjidx + 1;
                    while(idx <= stackTop) {
                        var owners = stack[idx].getEpsilonClosure().getOwners();
                        for(var o = 0; o < owners.length; ++o) {
                            owners[o].setEpsilonClosure(adjclosure);
                        }
                        ++idx;
                    }
                }
                else {
                    calcThruState(stack, stackTop + 1, adjstate, colorMap);
                }
            }
            v = valsGen.next();
        }
    }
    colorMap.set(state, 2); //black: finished
};

var addStatesToClosure = function (statearr, s, e, closurestates) {
    var clen = closurestates.length;
    while(s <= e) {
        var eclosure = statearr[s].getEpsilonClosure();
        for(var i = 0; i < clen; ++i)
            eclosure.addState(closurestates[i]);
        ++s;
    }
};

var printEpsilonClosure = function (states) {
    for(var i = 0 ; i <states.length; ++i) {
        var state = states[i];
        console.log(['epsilon closure of', state.getId(), ':', state.getEpsilonClosure().getStates().map(function(s){ return s.getId(); }).join(',')].join(' '));
    }
};

//should be used after 'calcEpsilonClosure' on all states
var test = function (states, str) {
    var slen = str.length, i = 0;
    if(!Array.isArray(states)) states = [states];
    states = epsilonClosureOfStates(states);
    while(states.length > 0 && i < slen) {
        var ch = str[i++];
        var movingstates = new Set();
        for(var j = 0; j < states.length; ++j) {
            var tset = states[j].getTransition(ch); //transition set
            if(tset == null) continue;
            var mstates = [...tset];
            for(var m = 0; m < mstates.length; ++m)
                movingstates.add(mstates[m]);
        }
        states = epsilonClosureOfStates([...movingstates]);
    }
    return i == slen && states.some(function(s){ return s.getTerminal(); });
};

var epsilonClosureOfStates = function (states) {
    var eclosure = new Set();
    for(var j = 0; j < states.length; ++j) {
        var closurestates = states[j].getEpsilonClosure().getStates();
        for(var c = 0; c < closurestates.length; ++c)
            eclosure.add(closurestates[c]);
    }
    return [...eclosure];
};

exports.calcEpsilonClosure = calcEpsilonClosure;
exports.printEpsilonClosure = printEpsilonClosure;
exports.epsilonClosureOfStates = epsilonClosureOfStates;
exports.test = test;
